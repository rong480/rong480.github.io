<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PIXI使用笔记（一）]]></title>
    <url>%2F2017%2F07%2F17%2FPIXI%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[以下文本均是基于PixiJS的V4版本。如有纰漏，还望各位斧正。 下面正式开始： 案例一 如果想使用PIXI，必须先引入pixi.js 1234&lt;script src="js/pixi.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //在此处写pixi的api&lt;/script&gt; 下面简单看看pixi的使用，首先，需要实例化一个渲染对象，用于渲染到页面上。 我们可以选用canvas或WebGL进行渲染一个区域，这里有个API，用于实例化一个canvas或WebGL区域。 里面的api参数有 下面一一介绍里面的API： 参数 参数说明 参数值 默认值 width 宽度 number 800 height 高度 number 600 view canvas作为一个视图使用（可选） HTMLCanvasElement transparent 是否呈现的视图是透明的 false/true false autoResize 是否渲染视图自动调整 false/true false antialias 设置抗锯齿，如果原生没有此功能，则使用FAXX抗锯齿功能 false/true false forceFXAA 高于原生抗锯齿强迫使用FXAA抗锯齿，FXAA是比较快的，但不是总看起来那么好 false/true false resolution 分辨率/像素的比例，当渲染到retina的设备时，此值设置为2 number 1 clearBeforeRender 这个设定设置是先清除canvas或者不在新渲染之前清除canvas；如果你想将此值设置为false，则必须设置preserveDrawingBuffer为true false/true true preserveDrawingBuffer 使用绘图缓存保护，使用这个在WebGL语境下如果你要调用toDataUrl false/true false roundPixels 当渲染时，是否PIXI使用X/Y的floor值，停止像素窜改值 false/true false backgroundColor 渲染区域的背景颜色 number 0x000000 legacy 是否PIXI真的将计划确保新旧设备的兼容性，是否你经历过不明的闪烁试着把这个值设置为true false/true false 12345678910var renderer = PIXI.autoDetectRenderer( 256, //设置元素的宽 256, //设置元素的高 &#123; autialiasing:false, //是否消除抗锯齿 transparent:false, //是否呈现的视图是透明的 resolution:1 //设置分辨率/像素的比例 &#125;, false //是否随意的强制画布渲染 ); 设置好以上的内容之后，然后将元素画到页面中： 123456document.body.appendChild(renderer.view);var stage = new PIXI.Container();renderer.view.style.border="1px dashed #f00";renderer.backgroundColor = 0xffffff;renderer.resize(512,512);renderer.render(stage); 这样就画出来一个带有一圈红色虚线边框的canvas了。]]></content>
      <categories>
        <category>PixiJS</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>canvas</tag>
        <tag>画布</tag>
        <tag>WebGL</tag>
        <tag>JavaScript库</tag>
        <tag>2D渲染器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iscroll.js 常用api]]></title>
    <url>%2F2017%2F07%2F05%2Fiscroll.js%20%E5%B8%B8%E7%94%A8api%2F</url>
    <content type="text"><![CDATA[iscroll简单介绍 官方介绍iscroll是这样的：iscroll不只会scroll，它能处理任何需要随着用户交互调整的元素。它增设有滚动、缩放、平移、无限滚动、滚动视差功能，传送到你的项目并且管理这些功能只用4kb。 iscroll的初始设置 先要引入iscroll，并在html加载后加载。 然后实例化iscroll给一个对象。 12345var myScroll = new IScroll('#wrapper', &#123; iscroll的api &#125;); iscroll里的重点 iscroll采用的是querySelector，而不是querySelectorAll； 这个插件需要知道滚动区域的高度和宽度； 需要为滚动起容器增加position:relative或者absolute样式； 如果滚动区域是个复杂的DOM结构，最好能在加载时候设置个延时，100ms到200ms较好。 iscroll里的api 核心(The core) 参数 参数说明 参数值 默认值 useTransform 引擎是否使用transform false/true true useTransition 引擎是否使用transition false/true true HWCompositing 引擎通过translateZ(0) false/true true 详细解释： 当useTransform值设置为false时，则滚动是以left/top属性值进行滚动；但值为true时，滚动是通过调整transform里的translate里的值实现滚动； 当useTransition值设置为false时，则使用requestAnimationFrame来进行代替，此时元素上不管如果拖动，都不会有有关transtion的属性；但值设置为true时，则动量和弹力是通过transtion-timing-function、贝塞尔曲线、transtion-duration的值来赋值。现在设备上这个值设置多少不太有影响，但是老设备上，用transition效果更好； 这个是使用在硬件层来改变CSS属性样式，设置为true的时候，在移动设备上将提高性能；但在有些情况下,你可能想要禁用它(特别是如果你有太多的元素和硬件性能跟不上)。 以上，核心的3个参数默认值都是true，都是利于我们开发的，所以，基本不用设置这些值。 基本功能(Basic features) 参数 参数说明 参数值 默认值 bounce 当滚动器到达容器边界时他是否执行一个小反弹动画 false/true true(有反弹动画) click 阻止默认浏览器里的鼠标点击事件 false/true false disableMouse 阻止鼠标事件 false/true false disablePointer 阻止指针事件 false/true false disableTouch 阻止触摸事件 false/true false eventPassthrough 只在iscroll范围内影响横向走马灯效果 false/true false freeScroll 在2D情况下，是否能够平面移动 false/true false keyBindings 激活键盘绑定 false/true false invertWheelDirection 反转鼠标滚轮方向 false/true false momentum 快速触摸屏幕时，可以开/关势能动画 false/true true mouseWheel 监听鼠标滚轮 false/true false preventDefault 默认事件 false/true true scrollbars 是否显示默认的滚动条 false/true false scrollX 横向移动 false/true false scrollY 纵向移动 false/true true startX 默认位置为基点滚动，基点的x轴的left值 数字 0 startY 默认位置为基点滚动，基点的y轴的top值 数字 0 tap 纵向移动 false/true true 详细说明： 先从我试出来的几个开始说起，bounce这个API的作用是，当你在元素边缘处继续向边缘拖动，如果该值为true，就能继续拖动并有个反弹的贝塞尔动画。如果是false，到边缘就无法继续拖动了，很显然这个值的默认值一般不用动； disableMouse、disablePointer、disableTouch这三个API的作用是，阻止不同操作的事件； eventPassthrough这个API是用来让元素横向移动，需要配合scrollX：true，此时即使scrollY设为true，也是不会有执行效果的； freeScroll这个API和scrollX与scrollY同时使用有不同之处：当调整一个方向的滚动时，另一个方向的滚动执行效果，想要无拘束的移动，就设置freeScroll为true就行了； invertWheelDirection这个API的作用是反向滚轮操作，需要配合mouseWheel：true，即可实现鼠标滚轮操作时，反向操作； momentum这个API的作用是是否打开势能动画的，如果设置为false值的话，会提升性能； mouseWheel这个API的作用是监听鼠标滚轮的操作，这条没什么好说的； preventDefault这个API尽量不设置，除非你知道自己要设置什么； startX和startY这两个API是用来设置初始的（0，0）点的位置，右为X轴正向，下为Y轴正向，设置的值只能是数字，比如设置startX为200，startY为200，出现效果是整体向下200px，向右200px，但是一挪动，就又回到初始的（0，0）点为基础点了； 为了重新写滚动条，所以iScroll禁止了一些默认的浏览器行为，所以想要响应click事件时，设置此值为true。但是不太好用，建议使用自定义的tap 事件来代替它； keyBindings暂时没有测试出来效果。 滚动条(Scrollbars) 参数 参数说明 参数值 默认值 scrollbars 用于激活滚动条 false/true false fadeScrollbars 用于滚动条淡入淡出的实现效果 false/true false interactiveScrollbars 用于用户是否可以拖动滚动条 false/true false resizeScrollbars 是否开启重新设置滚动条大小 false/true true shrinkScrollbars 是否在滚动条滚动出去之后会显示较小的尺寸 ‘clip’/'scale' false 详细说明： scrollbars这个值如果不设置成true的话，后面的api一点效果都没有； fadeScrollbars这个滚动条淡入淡出的效果如果设置成false的话，会节省些资源； interactiveScrollbars这个API是用来拖动滚动条的，别人手机测试没问题，我手机测试竖向滚动条拖动不了，很迷； shrinkScrollbars这个是设置滚动条滚动出去显示效果及尺寸，当设置为clip时，会大大提升性能，当设置为scale时，会自动关闭useTransition，即使将useTransition值设置为true都不行，使用的是使用requestAnimationFrame，还是对老设备不太友好，但是实现的效果好，各有利弊吧； 滚动条样式设置 类名 样式位置 .iScrollHorizontalScrollbar 指X轴方向的滚动条容器 .iScrollVerticalScrollbar 指Y轴方向的滚动条容器 .iScrollIndicator 真正的滚动条指示器 .iScrollBothScrollbars 只有在双向滚动条都有的时候，会出现 具体的结构是怎样实现的呢？ 123456&lt;div class="iScrollVerticalScrollbar iScrollBothScrollbars"&gt; &lt;div class="iScrollIndicator"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="iScrollHorizontalScrollbar iScrollBothScrollbars"&gt; &lt;div class="iScrollIndicator"&gt;&lt;/div&gt;&lt;/div&gt; 指示器(Indicators) 指示器和之前的写法有点不太一样,他的写法是在底层设置个对象。 举个例子： 12345678910111213141516var myScroll = new IScroll('#wrapper', &#123; indicators: &#123; el: [element|element selector] fade: false, ignoreBoundaries: false, interactive: false, listenX: true, listenY: true, resize: true, shrink: false, speedRatioX: 0, speedRatioY: 0, &#125; &#125;); 从这里开始，iscroll让你觉得它不再是个普通的插件。 下面一一介绍里面的API： 参数 参数说明 参数值 默认值 el 指向一个滚动区间，里面第一个元素就是指示器 写选择器 必选项 ignoreBoundaries 让指示器忽略它容器所带来的边界 false/true false listenX 指示器的X轴被监听 false/true true listenY 指示器的Y轴被监听 false/true true speedRatioX 指示器X轴移动速度和滚动条X轴移动速度的关系 number 0 speedRatioY 指示器Y轴移动速度和滚动条Y轴移动速度的关系 number 0 fade 元素是否隐藏 false/true false interactive 该元素是否可以拖动指示器移动 false/true false resize 是否开启重新设置指示器大小 false/true true shrink 指示器滑动出边界之外，是否会显示较小尺寸 ‘clip’/'scale' false 详细说明： 首先，el是必须得写的，一般赋值为：document.getElementById('earth')或者缩写为('#earth')。如果此项不写，就找不到相应对象； listenX和listenY如果设置为false，则不会根据滚动显示出来相应元素； speedRatioX和speedRatioY设置的时候，是为了有多个图层的状态，为了实现假3D效果； 使用指示器的功能，可以实现视差滚动。 滚动的编程接口 可以给myscroll赋予方法。以一种运动轨迹，跳转至某个位置。 有三种方式的编程接口： scrollTo(x, y, time, easing) 跳转到什么位置(x,y)，执行easing的时间都可以设置进去； scrollBy(x, y, time, easing) 同scrollTo有点像，是从当前位置滚动个相对位置(x,y)，执行easing的时间； scrollToElement(el, time, offsetX, offsetY, easing) 是跳转到对象元素，el是对象的选择器，time就是时间，offsetX和offsetY是跳转对象的横纵坐标偏移量，easing是运行的轨迹； 一般easing的运动轨迹是一个擦除动画，写法一般是IScroll.utils.ease.elastic，当然，除了有elastic之外，还有其他的动画类型：quadratic,circular,back,bounce,elastic。 对齐 对齐是为了让iscroll自动对齐到固定的位置和元素。 对齐实际测试，是为了拖动滚动条时，能够自动对齐元素，具体用法是这样的： 12345new IScroll('#wrapper', &#123; snap:"div", scrollbars:true, interactiveScrollbars:true, &#125;); snap的值，可以是true，选择器。 下面我们来试试用snap能实现什么样的效果： 首先引入goToPage(x, y, time, easing)，x是横向轴下一页，y是纵向轴下一页，time是经历时间，easing还是运行函数。 简单举个例子： HTML的文件结构是这样的： 12345678910111213141516171819&lt;div id=&quot;wrapper&quot;&gt; &lt;div id=&quot;iscroll&quot;&gt; &lt;div&gt;Lorem ipsum dolor sit amet, consectetur.&lt;/div&gt; &lt;button class=&quot;btnsnap&quot;&gt;SNAP&lt;/button&gt; &lt;div&gt;1Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;2Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;3Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;4Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;5Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;6Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;7Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;8Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;9Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;10Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;11Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;12Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;div&gt;13Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 我想实现点击button会跳转到第五段的效果，于是，js部分是这样的： 1234567891011121314151617181920212223242526272829var myScroll;myScroll = new IScroll(&apos;#wrapper&apos;, &#123; mouseWheel: true, scrollX: true, freeScroll: true, snap: &quot;div&quot;, scrollbars: true, interactiveScrollbars: true,&#125;);function isPassive() &#123; var supportsPassiveOption = false; try &#123; addEventListener(&quot;test&quot;, null, Object.defineProperty(&#123;&#125;, &apos;passive&apos;, &#123; get: function() &#123; supportsPassiveOption = true; &#125; &#125;)); &#125; catch (e) &#123;&#125; return supportsPassiveOption;&#125;document.addEventListener(&apos;touchmove&apos;, function(e) &#123; e.preventDefault();&#125;, isPassive() ? &#123; capture: false, passive: false&#125; : false);$(&quot;.btnsnap&quot;).on(&quot;click&quot;, function() &#123; myScroll.goToPage(0, 5, 1000, IScroll.utils.ease.elastic);&#125;) 这样就跳转到第五段了。 除了有goToPage()这个方法：还有**next()和prev()**两个方法，分别是用来跳转到下一页和上一页。 缩放 为了使用缩放功能，最好我们引入iscroll-zoom.js。 下面一一介绍里面的API： 参数 参数说明 参数值 默认值 zoom 是否缩放 false/true false zoomMax 缩放最大尺寸比例 number 4 zoomMin 缩放最小尺寸比例 number 1 zoomStart 缩放级数 number 1 wheelAction 鼠标滚轮是否能起到缩放功能 zoom undefined zoomMax 缩放最大尺寸比例 number 4 zoomMax 缩放最大尺寸比例 number 4 zoomMax 缩放最大尺寸比例 number 4 详细说明： 首先，zoom是必须要设置成为true的，否则无法使用缩放功能； wheelAction如果不设置为‘zoom’的话，他的初始值就是‘undefined’，是鼠标滚轮就起滚轮左右，不能起缩放功能； zoom是通过transform属性的scale值进行缩放的，所以你懂的，兼容问题；]]></content>
      <categories>
        <category>JavaScript库</category>
        <category>iscroll</category>
      </categories>
      <tags>
        <tag>JavaScript库</tag>
        <tag>js库</tag>
        <tag>iscroll</tag>
        <tag>iscroll.js</tag>
        <tag>移动端</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustache.js 基础（三）]]></title>
    <url>%2F2017%2F07%2F04%2FmustacheJS-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[mustache的partials partials开始是以一个大于号“&gt;”开始的，{{&gt;partials}}。 partials在运行时渲染，而不是在编译时，所以递归的partials是可行的。要避免无限循环。 他们也继承了调用上下文，而在ERB中你可能会看到： &lt;%= partial :next_more, :start =&gt; start, :size =&gt; size %&gt; 但是在mustache里只要这样： {{&gt; next_more}}]]></content>
      <categories>
        <category>JavaScript库</category>
        <category>mustache</category>
      </categories>
      <tags>
        <tag>JavaScript库</tag>
        <tag>js库</tag>
        <tag>mustache</tag>
        <tag>mustache.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustache.js 基础（二）]]></title>
    <url>%2F2017%2F07%2F04%2FmustacheJS-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[mustache的Sections（节） 根据上下文键值，节一次或者多次渲染出文本块。节以“#（pound ）”开始，以“/”结束。 比如{{#person}}开始一个person节，然后以{{/person}}结束它。两个标记之间的文本，被称为是该节的块。节的行为由键值决定。 false值和空列表 如果person的键不存在，或者存在并且有个值为：null、undefined、0、NaN、false、空字符串、空列表，则块不会被渲染。 当值是一个列表的时候，该块对列表中的每一项都进行一次渲染。块的环境在每次循环中，都会设置为列表中的当前项。以这种方式，我们可以循环把元素渲染到页面上。 举个例子： 在body内写入以下内容之后： 1234567891011121314151617181920212223242526&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; names:[ &#123;name:&quot;smith&quot;&#125;, &#123;name:&quot;billy&quot;&#125;, &#123;name:&quot;joe&quot;&#125;, &#123;name:&quot;mike&quot;&#125;, &#123;name:&quot;fez&quot;&#125; ] &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt; &#123;&#123;#names&#125;&#125; &lt;b&gt;&#123;&#123;name&#125;&#125;&lt;/b&gt; &lt;br/&gt; &#123;&#123;/names&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果就是： smith billy joe mike fez 当在一个字符串数组上循环时，一个“.”（点）可以被用来引用列表中的当前项。而以其他形式存储的数据，是无法通过“.”来循环渲染的。 举个例子： 12345678910111213141516171819202122&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; names:[ &quot;smith&quot;,&quot;billy&quot;,&quot;joe&quot;,&quot;mike&quot;,&quot;fez&quot; ] &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt; &#123;&#123;#names&#125;&#125; &lt;b&gt;&#123;&#123;.&#125;&#125;&lt;/b&gt; &lt;br/&gt; &#123;&#123;/names&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： smith billy joe mike fez 同上一个例子出来的效果一样。 如果一个区段变量是一个函数，它将在每次迭代列表中当前项的环境调用。 举个例子： 1234567891011121314151617181920212223242526272829&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; singers:[ &#123;firstname:&quot;smith&quot;,lastname:&quot;white&quot;&#125;, &#123;firstname:&quot;billy&quot;,lastname:&quot;black&quot;&#125;, &#123;firstname:&quot;joe&quot;,lastname:&quot;yeo&quot;&#125;, &#123;firstname:&quot;mike&quot;,lastname:&quot;bay&quot;&#125;, &#123;firstname:&quot;fez&quot;,lastname:&quot;fez&quot;&#125;, ], showname:function()&#123; return this.firstname+&quot;.&quot;+this.lastname &#125; &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt; &#123;&#123;#singers&#125;&#125; &lt;b&gt;&#123;&#123;showname&#125;&#125;&lt;/b&gt; &lt;br/&gt; &#123;&#123;/singers&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： smith.white billy.black joe.yeo mike.bay fez.fez 通过此方法，可以用mustache进行一次简单的过滤判断，然后渲染到页面上。再举个例子： 12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; scores:[ &#123;title:&apos;震惊&apos;,score:78&#125;, &#123;title:&apos;啊&apos;,score:50&#125;, &#123;title:&apos;哦&apos;,score:90&#125;, &#123;title:&apos;咦&apos;,score:23&#125;, &#123;title:&apos;嗯&apos;,score:46&#125;, &#123;title:&apos;呦&apos;,score:100&#125;, ], showscores:function()&#123; if(this.score&gt;70)&#123; return &quot;&lt;b&gt;&quot;+this.title+&quot;:&quot;+this.score+&quot;&lt;/b&gt;&lt;br/&gt;&quot;; &#125; else&#123; return; &#125; &#125; &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt; &#123;&#123;#scores&#125;&#125; &#123;&#123;&#123;showscores&#125;&#125;&#125; &#123;&#123;/scores&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： 震惊:78 哦:90 呦:100 总结一下以上代码踩坑经历： 首先，我的function里做了个判断，然后把符合的值传了出来，之前写的是： 12345678showscores:function()&#123; if(this.score&gt;70)&#123; return this.title+&quot;:&quot;+this.score; &#125; else&#123; return false; &#125; &#125; 然后template那里是这么写的： 123 &#123;&#123;#scores&#125;&#125;&lt;b&gt;&#123;&#123;showscores&#125;&#125;&lt;/b&gt;&lt;br/&gt;&#123;&#123;/scores&#125;&#125; 结果，出来的效果是这样的： 震惊:78 false 哦:90 false false 呦:100 很明显这不是我想要的效果，于是，我把else里的return false改成return；了，结果出来的结果是： 震惊:78 哦:90 呦:100 结果中间return；的位置，还是用空来代替了，还是执行了&lt;br/&gt;标签，于是我想到了用三个胡子写法。就是最终实现效果的写法。 函数 如果一个节的键值是一个函数，那么这个键值就会被作为该节的第一个参数，被原义的文本块调用，且不会被渲染。第二个参数是一个特殊的渲染函数，它使用了当前视图作为视图参数。它是在当前视图对象的上下文中调用的。 还是举个例子： 12345678910111213141516171819202122&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; name: &quot;Rong&quot;, bold: function() &#123; return function(text, render) &#123; return &quot;&lt;b&gt;&quot; + render(text) + &quot;&lt;/b&gt;&quot;; &#125; &#125; &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt; &#123;&#123;#bold&#125;&#125; Hi &#123;&#123;name&#125;&#125; &#123;&#123;/bold&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： Hi Rong mustache的Inverted Sections（反转节） 一个反转节用{{^section}}取代了{{#section}}来开头，反转节只有在这个标签内的值为null、undefined、false、非法写法、空列表的时候才会渲染。 继续举个例子： 123456789101112131415161718&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; name:[] &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt;&#123;&#123;#name&#125;&#125;如果不为空，显示你&#123;&#123;/name&#125;&#125;&#123;&#123;^name&#125;&#125;如果为空，显示你&#123;&#123;/name&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： 如果为空，显示你 mustache的注释 注释是以一个感叹号&quot;!&quot;开始，然后里面的内容就会被忽略。以下为测试： 1234567891011121314151617&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; name:[“aa&quot;,&quot;bb&quot;] &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt;&lt;p&gt;what is &#123;&#123;! name&#125;&#125;&lt;/p&gt;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： what is 下次我们继续来说mustache.js基础。]]></content>
      <categories>
        <category>JavaScript库</category>
        <category>mustache</category>
      </categories>
      <tags>
        <tag>JavaScript库</tag>
        <tag>js库</tag>
        <tag>mustache</tag>
        <tag>mustache.js</tag>
        <tag>section</tag>
        <tag>inverted sections</tag>
        <tag>mustache注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustache.js 初识（一）]]></title>
    <url>%2F2017%2F06%2F26%2FmustacheJS-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[mustache.js 介绍 出于mustache在github上有好多，我此次学习的是janl/mustache， language为JavaScript的那个。 mustache.js概念 官方文档第一句： What could be more logical awesome than no logic at all? 我翻译不出来，简单就是说，还有什么比毫无逻辑更可怕。 然后作者第一句解释mustache是什么，是这样写的： mustache.js is an implementation of the mustache template system in JavaScript. 我简单翻译过来：mustahce是一个以JavaScript语言实现的mustache模板系统执行者。 然而好像没法看懂啊，这好像提取不出来什么有用的信息啊！ 紧接着这段重要了啊！！！知识点！！！ Mustache is a logic-less template syntax. It can be used for HTML, config files, source code - anything. It works by expanding tags in a template using values provided in a hash or object. 我简单翻译一下： Mustache是一个少逻辑的模板语法。它可以用于HTML，配置文件，源代码等任何东西。它通过散列或对象提供的值来扩展模块的标签。 重点词有：少逻辑，模板，可以用于任何东西，通过散列或者对象来扩展标签。 至此，mustache.js解释出来了。下面我们来看看mustache.js如何使用？ mustache引用 当要使用mustache.js时，需要先引入mustache.js文件到需要用的页面里去。如果是模块打包生成的项目，需要 npm install mustache 引入了mustache之后，我们就要看如何使用mustache了。 mustache 使用 mustache使用 先举个例子，先定义一个对象 1234567var view = &#123; title: "Joe", calc: function () &#123; return 2 + 4; &#125;&#125;;var output = Mustache.render("&#123;&#123;title&#125;&#125; spends &#123;&#123;calc&#125;&#125;", view); 在示例中，Mustache.render内有两个参数，第一个参数为mustache模板，第二个为view对象，里面装着用来渲染进模板的数据或者代码。 mustache的API mustache里的api有： 12345678910Mustache.render( template : String, //模板 view : Object, //渲染进模板的数据 partials : Object //(可有可无，之后再谈)) =&gt; StringMustache.parse( template : String, //模板 tags = ['&#123;&#123;' , '&#125;&#125;'] : Tags, //放入模板的数据) =&gt; Stringinterface Tags [String,String] mustache的Templates 一个mustache的模板是一个包含任何数量的mustache标签的字符串。标签是被两个胡子括号（即“{{}}”）包裹起来的。例如：{{person}}是一个标签，{{#person}}也是一个标签。在上面两个例子中，我们都将person称作是标签的键。在mustache.js可用标签的几种类型，见以下描述： 有几种方法可以用来加载模板，并把它们提交给mustache.js，分为以下两种： 包括模板 如果你需要在静态页面中添加为了动态数据的模板，你可以直接在静态页面中写入模板，就不用单独加载模板了。以下有个使用jQuery的小例子： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body onload="loadUser()"&gt;&lt;div id="target"&gt;Loading...&lt;/div&gt;&lt;script id="template" type="x-tmpl-mustache"&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456function loadUser() &#123; var template = $('#template').html(); Mustache.parse(template); // optional, speeds up future uses var rendered = Mustache.render(template, &#123;name: "Luke"&#125;); $('#target').html(rendered);&#125; 实现的效果就是，先是页面加载，当页面加载完成后，页面渲染出Hello Luke！ 加载外部模板 如果你把模板放到一个单独文件内，你可以异步加载它，并在获取数据后执行渲染。以下有另一个使用jQuery的小例子： 123456function loadUser() &#123; $.get('template.mst', function(template) &#123; var rendered = Mustache.render(template, &#123;name: "Luke"&#125;); $('#target').html(rendered); &#125;);&#125; mustache的变量 最基本的标记类型是一个简单的变量，比如一个{{name}}标签渲染的就是上下文中键值为name的内容，如果没有这样的键值，就什么都不会渲染。 默认的情况下，所有的变量都是转义的HTML，如果你想渲染非转义的HTML，就使用三个胡子括号包起来，也可以使用&quot;&amp;&quot;符号来渲染非转义的HTML。我们下面举个例子来说明上面的情况 1234567891011&lt;div class="three-mustache"&gt;&lt;/div&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/mustache.min.js"&gt;&lt;/script&gt;&lt;script src="js/data.js"&gt;&lt;/script&gt;&lt;script&gt; var view = &#123; namethree:"&lt;strong&gt;what&lt;/strong&gt;" &#125;; var output=Mustache.render("&#123;&#123;namethree&#125;&#125;", view); $('.three-mustache').html(output);&lt;/script&gt; 这么写之后，页面会显示如下这样的效果： &lt;strong&gt;what&lt;/strong&gt; 这样并没有实现我想加粗的效果啊，虽然加粗很容易，但是我现在就想让他加粗，于是，试了试三个胡子写法，如下： 1234567891011&lt;div class="three-mustache"&gt;&lt;/div&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/mustache.min.js"&gt;&lt;/script&gt;&lt;script src="js/data.js"&gt;&lt;/script&gt;&lt;script&gt; var view = &#123; namethree:"&lt;strong&gt;what&lt;/strong&gt;" &#125;; var output=Mustache.render("&#123;&#123;&#123;namethree&#125;&#125;&#125;", view); $('.three-mustache').html(output);&lt;/script&gt; 页面显示如下效果： what 很好，达到我们想要的了，现在再测试以下这么写会有什么效果： 1234567891011&lt;div class="three-mustache"&gt;&lt;/div&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/mustache.min.js"&gt;&lt;/script&gt;&lt;script src="js/data.js"&gt;&lt;/script&gt;&lt;script&gt; var view = &#123; namethree:"&lt;strong&gt;what&lt;/strong&gt;" &#125;; var output=Mustache.render("&#123;&#123;&amp;namethree&#125;&#125;", view); $('.three-mustache').html(output);&lt;/script&gt; 测试出来的显示如下效果： what 最后，我们试一个特别神奇的测试，如下： 1234567891011&lt;div class="three-mustache"&gt;&lt;/div&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/mustache.min.js"&gt;&lt;/script&gt;&lt;script src="js/data.js"&gt;&lt;/script&gt;&lt;script&gt; var view = &#123; namethree:"&lt;strong&gt;what&lt;/strong&gt;" &#125;; var output=Mustache.render("&#123;&#123;=&lt;% %&gt;=&#125;&#125;&#123;&#123;namethree&#125;&#125;&lt;%=&#123;&#123; &#125;&#125;=%&gt;", view); $('.three-mustache').html(output);&lt;/script&gt; 测试出来的显示如下效果： {{namethree}} 是不是很神秘，今天就写到这，下次我们来说mustache.js基础篇。]]></content>
      <categories>
        <category>JavaScript库</category>
        <category>mustache</category>
      </categories>
      <tags>
        <tag>JavaScript库</tag>
        <tag>js库</tag>
        <tag>mustache</tag>
        <tag>mustache.js</tag>
        <tag>logic-less</tag>
        <tag>API</tag>
        <tag>Template</tag>
        <tag>Variables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TweenJS 初识（一）]]></title>
    <url>%2F2017%2F06%2F21%2FTweenJS-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[TweenJS介绍 什么是TweenJS 在github上，Tweenjs是这么介绍自己的： TweenJS is a simple tweening library for use in Javascript. It was developed to integrate well with the EaselJS library, but is not dependent on or specific to it (though it uses the same Ticker and Event classes by default). It supports tweening of both numeric object properties &amp; CSS style properties. 翻译一下：Tweenjs是一个使用JavaScript的简单的动画库。它被开发为了与EaselJS更好的组合使用，但是它不依赖于EaselJS也不特定于EaselJS（尽管它默认使用相同的代码和事件的类），它接受数字对象属性和CSS样式属性的赋值。 从上面我们提取关键词：js库，基于EaselJS但不依赖于它，接受数字对象属性和CSS样式属性赋值。 有点容易理解了，下面试试怎么使用它。 第一次使用TweenJS 简单做个小canvas，首先，把html页面搭好，在里面写好600×600大小的canvas，赋个id为canvas。 然后，引入Tween.js文件 1&lt;script src="js/Tween.js"&gt;&lt;/script&gt; 引入Tween.js文件后，就可以使用TweenJS里的东西了。 在这段代码之前，先引入个概念，叫window.requestAnimationFrame(),MDN上对它进行了解释： The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes as an argument a callback to be invoked before the repaint. 翻译一下：这个window.requestAnimationFrame()的方法告诉浏览器你想要执行一个动画了，并且浏览器告知一个特殊的函数在下一次动画来临前更新画面。这个方法是传递给requestAnimationFrame()一个回调函数。 方法有点类似于setTimeout()。但不同是这个方法是专门为动画提供的API。 123456789101112131415161718&lt;script type="text/javascript"&gt; var canvas = document.getElementById('canvas'); //找到canvas var ctx = canvas.getContext('2d'); //定义canvas为2d效果绘制 var position = &#123; x: 100, y: 100 &#125;; //定义初始位置坐标 var tween = new TWEEN.Tween(position) //实例化一个对象tween，定位作为值传入 .to(&#123; x: 400,y:400 &#125;, 1000) //目标位置坐标，定义时间为1秒钟 .onUpdate(function()&#123; //在修改时，执行回调函数 ctx.fillStyle = 'rgba(150, 23, 207, 0.41)'; //给canvas里小元素赋颜色 ctx.fillRect(position.x,position.y,4,4); //让他在canvas上画4*4的小方块，位置在定义的位置坐标上 &#125;) .start(); //让Tween开始 function animate(time) &#123; //定义一个动画函数 window.requestAnimationFrame(animate); //把animate作为回调函数传给requestAnimationFrame()方法 TWEEN.update(time); //调用TWEEN.update()方法，实现平滑动画效果 &#125; animate(); //执行动画函数&lt;/script&gt; 实现的效果应该是从canvas上的（100，100）坐标位置开始，一串紫色小方块直到（400，400）坐标位置为止。 这就是我写的第一个基于TweenJS的第一个效果。]]></content>
      <categories>
        <category>JavaScript库</category>
        <category>TweenJS</category>
      </categories>
      <tags>
        <tag>JavaScript库</tag>
        <tag>js库</tag>
        <tag>Tween</tag>
        <tag>TweenJS</tag>
        <tag>window.requestAnimationFrame()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animation用法总结]]></title>
    <url>%2F2017%2F06%2F21%2FAnimation-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引入 首先，说一下为什么要使用 Animation 呢？为什么我们不用 transition 呢？下面我来总结一下transition的局限性。 transition的使用是需要有事件触发的，所以无法在网页加载无事件时自动发生； transition只能用于定义开始状态和结束的状态，不能定义中间状态值，即要实现一个简单的逐帧动画是无法实现的； transition是一次性的属性，不能够反复发生，除非设置成多次触发，不能够自身循环； 一条transition的规则内，只能定义一个属性的状态变化及其相应的变化方式和时间轨迹，不能同时给两个属性同时赋值（除非同时给所有值赋值相同的变化方式和时间轨迹），即写法相对的繁冗。如下： 1234567891011.transitiondemo&#123; width:200px; height: 200px; background: #f00; transition: 2s height,1s 1s width,3s background;&#125;.transitiondemo:hover&#123; width: 500px; height:600px; background: #0f0;&#125; transition里面的属性每条都需要单独来写，解释了transition里的第4条。 这时，CSS3里的Animation就出来解决这些问题了。 Animation 基本用法 在body标签里创建个div，赋个类名叫animationdemo，然后写好他的初始样式： 12345.animationdemo&#123; width:200px; height: 200px; background: #f00;&#125; 然后，要让他动画起来，首先，要给他一个动画名和持续时间： 123.animationdemo:hover&#123; animation: 3s animatedemo;&#125; 这里面的 3s 是指这个动画持续的时间， animatedemo 则是我定义的动画名，现在需要设置动画过程，这里要引入一个创建动画的 @keyframes 规则： 1234@keyframes animatedemo &#123; 50% &#123;background: #0f0&#125; 100% &#123;background: #00f&#125;&#125; @keyframes + 动画名{动画过程}，然后在动画过程部分，写上占动画时间百分比，修改的属性及属性值，动画会圆滑的过渡到你设置的位置。 个人理解 ：此处加个写动画时间和百分数不是随意写的，现在市面的显示器，一般为60帧（即将一秒平分60份，每份16.666...667ms），所以设置动画时需要算一下帧数。 组合起来，CSS内的代码是这样的： 123456789101112.animationdemo&#123; width:200px; height: 200px; background: #f00;&#125;.animationdemo:hover&#123; animation: 3s animatedemo;&#125;@keyframes animatedemo &#123; 50% &#123;background: #0f0&#125; 100% &#123;background: #00f&#125;&#125; 当然，hover里面animation属性的写法是简写的，也可以写成这样： 1234.animationdemo:hover&#123; animation-name: animatedemo; /*动画名*/ animation-duration: 3s; /*动画持续时间*/&#125; 现在，我们要挨个介绍animation里的属性了。 animation里的主要属性 animation-delay 这个animation的属性是： animation-delay 。它的属性值为 .. s(几秒)，指的是这个动画要延迟多长时间再进行。 123.animationdemo:hover&#123; animation-delay: 1s; /*动画延迟时间*/&#125; animation-iteration-count 这个animation的属性是： animation-iteration-count 。它的属性值通常是数字和'infinite'，指的是这个动画要重复循环多少次，如果不设置此值，动画即进行一次结束，属性值设置为 infinite 后，即可让动画无限循环。 123.animationdemo:hover&#123; animation-iteration-count: infinite; /*动画循环次数*/&#125; animation-fill-mode 这个animation的属性是： animation-fill-mode 。指动画结束那一瞬间停留的状态，默认值为 none，即回到动画没开始时的状态。 该属性的属性值有以下几种： 属性值 属性值解释 none 默认值，回到动画没开始的状态 forwards 动画停留在动画结束最后一帧的状态 backwards 动画停留在动画开始的第一帧的状态 both 根据animation-direction属性，轮流使用backwards和forwards 123.animationdemo:hover&#123; animation-fill-mode: both; /*动画结束时停留的状态*/&#125; animation-direction 这个animation属性是： animation-direction 。指动画循环播放时动画的播放方向，默认值为normal：即第一次动画时顺序播放，紧接着的下一个动画还是顺序播放，以此类推。 该属性的属性值有以下几种： 属性值 属性值解释 normal 默认值，第一次动画顺序播放，接着的动画都为顺序播放 alternate 第一次动画为顺序播放，接着下一个动画播放顺序与上一个动画顺序相反 reverse 第一次动画逆序播放，接下来的动画都为逆序播放 alternate-reverse 第一次动画为逆序播放，接着下一个动画播放顺序与上一个动画顺序相反 123.animationdemo:hover&#123; animation-direction: alternate; /*动画循环播放的播放方向*/&#125; animation-play-state 这个animation的属性是： animation-play-state 。指动画循环时突然打断的状态，没有默认值，如不设置此值，默认的状态是，当打断动画，动画会自动回到动画的第一帧状态；当设置成paused值时，动画即使被打断，也停留在打断时的动画帧数，不会跳转到动画初始帧。 该属性的属性值有以下几种： 属性值 属性值解释 running 规定动画播放 paused 规定动画暂停 1234567891011.animationdemo&#123; width:200px; height: 200px; background: #f00; animation: 3s 1s animatedemo infinite both alternate; animation-play-state: paused; /*规定动画暂停*/&#125;.animationdemo:hover&#123; animation-play-state: running; /*规定动画播放*/&#125; 可以看到，如果没有发生hover动作的时候，他是停留在paused状态下的，当hover上时，动画会进行，突然不hover时，动画不会回到第一帧，会暂停在当前动画进行的状态 此属性通过js来控制，可以实现更多效果，主要为了突然停止动画，停在当前运行状态。 属性总结 123456789 .animationdemo:hover&#123; animation-name: animatedemo; /*动画名*/ animation-duration: 3s; /*动画持续时间*/ animation-delay: 1s; /*动画延迟时间*/ animation-iteration-count: infinite; /*动画循环次数*/ animation-fill-mode: both; /*动画结束时停留的状态*/ animation-direction: alternate; /*动画循环播放的播放方向*/animation-play-state: paused; /*规定动画暂停*/ &#125; 当然，以上的属性值都是可以简写成一行的，比如 123456.animationdemo&#123; animation: 3s 1s animatedemo infinite both alternate paused;&#125;.animationdemo:hover&#123; animation-play-state: running;&#125; 以上，为animation里的主要属性，下面来介绍介绍keyframes。 @keyframes @keyframes 是用来定义动画的具体流程的，在里面可以写动画过程的各个状态值。格式如下： @keyframes 动画名{ 动画进行的百分比 {属性1：属性值；属性2：属性值；属性3...} 动画进行的百分比 {属性1：属性值；属性2：属性值；} } 具体写法见下： 12345@keyframes animatedemo &#123; /*animatedemo为我设置的动画名*/ 0% &#123;background: #f0f;width:300px;&#125; /*属性1为background;属性2为width；*/ 50% &#123;background: #0f0;&#125; /*属性1为background；属性2没写，即回到元素该属性值的状态*/ 100% &#123;background: #00f;&#125;&#125; 里面得0%可以用from代替，100%可以用to代替。 12345@keyframes animatedemo &#123; /*animatedemo为我设置的动画名*/ from &#123;background: #f0f;width:300px;&#125; /*属性1为background;属性2为width；*/ 50% &#123;background: #0f0;&#125; /*属性1为background；属性2没写，即回到元素该属性值的状态*/ to &#123;background: #00f;&#125;&#125; 总结 animation属性解决掉了transition局限性，更为好用。 好的animation不止是设计的良苦用心，也是前端的细心和想象力。 说了很多，但是想要做出好的效果还是很难的，这里感谢阮一峰的博客，菜鸟教程。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
        <tag>Animation</tag>
        <tag>样式</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2017%2F06%2F05%2F%E9%9D%A2%E8%AF%95html%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[HTML HTML简介 HTML]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-基础（三）]]></title>
    <url>%2F2017%2F04%2F24%2FReact-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先，生成新的react文件夹，还是要删除所有东西，只留index.js和logo.svg 在index.js中创建新的项目 12345678import React from 'react'import ReactDOM from 'react-dom'import App from './app.js'ReactDOM.render( &lt;App /&gt;, document.getElementById('root')) 再在同级文件夹内，创建app.js文件，在app.js文件内输入： 123456789101112131415161718192021import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); this.state=&#123; times:'second' &#125; &#125; times(t)&#123; return(t) &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;hello world &#123;this.state.times&#125;&lt;/h1&gt; &lt;h1&gt;hello world &#123;this.times("3rd")&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125; 这样很好理解，现在说一个新的点，react中的事件 React事件 比如在app里面添加一个按钮，让它具有onClick事件。在app.js中继续输入： 1234567891011121314151617import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); &#125; clickHandler()&#123; alert("好玩么？") &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.clickHandler&#125;&gt;点击按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 这样，就实现了点击按钮，会弹出对话框的效果。 我们再试试如下的按钮会实现吗？ 1234567891011121314151617181920212223242526272829import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); this.state=&#123; count:0 &#125; &#125; clickHandler()&#123; alert("好玩么？") &#125; addHandler()&#123; this.setState( &#123; count:this.state.count+1 &#125; ) &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.clickHandler&#125;&gt;点击按钮&lt;/button&gt; &lt;h2&gt;你刚刚点击了下面的按钮几次&lt;/h2&gt; &lt;button onClick=&#123;this.addHandler&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 当点击+1按钮时，console控制台会输出：&lt;font color=red&gt;Uncaught TypeError:Cannot read property 'setState' of null at addHandler&lt;/font&gt; 到底是什么意思呢，简单翻译过来就是 未能捕获类型错误：不能找到在addHandler中的空具有的“setState”属性。翻译过来好像不像人话，简单解释一下，就是因为this的指向有问题，所以，会把this指向null。具体解释下： 先看&lt;button onClick={this.addHandler}&gt;+1&lt;/button&gt;中的this的指向是没问题的，是指向App的，但是在点击时候，是按钮在调用这个对象（this.addHandler），但是，我们现在是个虚拟的 DOM Tree，它里面是没有真正的button，所以此时的button实际是null，那如何实现这样的绑定呢？ bind（） bind()方法，绑定方法，能改变一个对象的上下文环境,bind后面写着哪个对象，就会让前面的方法指向哪个对象 在constructor中加入this.addHandler = this.addHandler.bind(this); 绑定后，addHandler方法中的this就能正确的指向。 怎么能看到我们的state里的count值变了呢？此处，我们需要下载一个能测试react改变的状态值的小插件，我在chrome浏览器登陆谷歌网上应用商店，搜索React Developer Tools，并下载，就能实现看到react改变状态值了。 最好将所有调用的事件都bind()一下，这个是有必要的。 react里的for循环 有的时候，我们需要将]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-基础（二）]]></title>
    <url>%2F2017%2F04%2F22%2FReact-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一回我们说到了react需要的准备，现在我们说说如何使用React吧。 react的前置概念 React有一个核心思想---组件化 有两个带头大哥---react和react-dom 一个基本运作方式---数据驱动视图 一个神秘卧底---jsx语法 三个主要帮手---state（状态）、props（属性）、refs（实例） 打杂小弟---声明周期 react的使用 react的两个带头大哥和神秘卧底jsx 这么说完是不是什么都看不明白，好，我们具体举例子，在gitbash中输入 $ create-react-app &lt;file&gt; 创建好文件夹后，在文件夹内运行npm start，默认打开localhost：3000端口可以打开默认react页面。 在创建的文件夹内的public内，用编译器打开index.html，我们发现这个html内，除了一个id=root的空div之外，剩下没什么有用的内容了，但是是什么驱动了react默认页面的呢？ 我们把src内除了logo.svg与index.js之外的其他文件都删除掉，并且把index.js内容都删除掉。 现在再加载npm start是不是页面上就应该什么都没有了，然后我们要自己在index.js文件里写些语句来实现数据驱动视图 12345678910//首先引入两个重要的模块import React from 'react'import ReactDOM from 'react-dom'//react-dom 负责页面内容的控制ReactDOM.render( &lt;h1&gt;我是react生成的内容&lt;/h1&gt;, document.getElementById('root')) 再在bash命令行里输入&quot;npm start&quot;，就可以在localhost：3000端口表现页面了 react-dom 这样页面就可以显示出“我是react生成的内容”，其中react-dom有两个参数： 渲染的内容； 渲染进页面的位置。 jsx 渲染进页面的内容的h1标签是怎么被实现出来的呢？ 这里我请出了神秘卧底 jsx，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 我们不需要一定使用jsx，但它有以下优点： JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化； 它是类型安全的，在编译过程中就能发现错误； 使用 JSX 编写模板更加简单快速。 react 刚刚使用react-dom了，但是为什么要先引入react这个模块呢？因为我使用了 jsx，如果不引入react模块，则无法读取jsx语句 react的组件 我们引入新的概念：react中的组件 现在刚刚输入的index.js中继续输入，当输入以下内容时： 12345ReactDOM.render( &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt;, document.getElementById('root')) 页面是会报错，不会显示任何内容，主要原因是，react-dom的第一个参数：渲染的内容，必须是由一个闭合标签引入。以上的内容可以通过以下解决报错问题： 1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt; &lt;/div&gt;, document.getElementById('root')) 这样就可以了，第一个参数必须是闭合的标签，且里面的内容也应该是闭合的标签。 然后我们说react中的组件,先举个例子 12345678910111213141516171819//自定义一个Ul组件class Ul extends React.Component&#123; render()&#123; return( &lt;ul&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;/ul&gt; )&#125; &#125;ReactDOM.render( &lt;div&gt; &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;Ul /&gt; &lt;/div&gt;, document.getElementById('root')) 如果引用react中的组件，必须先自定义个组件。 具体操作为：class “Name” extends React.Component{render(){return(闭合的要渲染进去的内容)}} 在index.js中可以引入渲染中需要的css的。 现在index.js先引入css文件： 1import "./index.css" 渲染的时候就可以添加样式了。 插值可以是简单的表达式 123456789101112131415161718192021class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125; 渲染到html上就是： 12342假的hello world下午8:00:51 但显示的时间仅是现在的时间，不能及时修改时间，我们暂且用这种想法试试呢？ 123456789101112131415161718192021222324class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; setInterval(()=&gt;&#123; this.state.time=(new Date()).toLocaleTimeString() &#125;,1000) &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125; 这样的写法也不会及时更改时间，永远不要直接修改state，如果要出现页面view的变化，要通过setState方法 123setInterval(()=&gt;&#123; this.setState(&#123;time:(new Date()).toLocaleTimeString()&#125;) &#125;,1000) 这样显示的就是即时时间 但都写在一个文件里，不太好，能不能通过引用组件呢？ 我们在index.js里写： 1import Ul from './Ul.js' 为什么此处的Ul要大写呢？ 因为jsx语法中，当开头字母是小写的时候，即判定为element，也就是普通网页上的标签，首字母大写的，被定义为自定义组件标签。 在同级创建个Ul.js文件 可以把有关Ul组件的东西考到Ul.js里，一定要在Ul.js里引用react，并在最后抛出Ul组件 则在Ul.js里写： 12345678910111213141516171819202122232425262728import React from "react"class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; setInterval(()=&gt;&#123; this.setState(&#123;time:(new Date()).toLocaleTimeString()&#125;) &#125;,1000) &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125;export default Ul jsx并不是真正的HTML标签，而是虚拟的DOM Tree 我们会发现，刚刚实现的网页，在浏览器上，对象里，有个div，既不在head标签内，也不再body标签内，而是单独的一个div，点开会发现，里面有个#shadow-root,这个东西就是个 虚拟的 DOM Tree，他是DOM结构的一个映射，一个影子。 即在react一般不会在真实的DOM Tree里操作，一般是在虚拟的DOM Tree中实现，再投射在真实的DOM Tree。 这里再说一下react厉害之处，它可以识别到真实的DOM Tree和虚拟的DOM Tree。比如刚刚的时间，原来使用的是把整个页面都重新刷新一遍，现在，只需要刷新时间这部分的内容就可以了。 jsx中的{}插值的位置都很随意。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React基础</tag>
        <tag>react</tag>
        <tag>react-dom</tag>
        <tag>数据驱动视图</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 初识（一）]]></title>
    <url>%2F2017%2F04%2F18%2FReact-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[React是什么？ React.js（React）github上的原文解释是 A declarative, efficient, and flexible JavaScript library for building user interfaces. 我个人翻译过来，一个 声明的，高效的，灵活的JavaScript库来构建用户界面。 React的起源 React起源于Facebook的内部项目，因为该公司对市场上所有的JavaScript MVC框架，都不满意，于是他们就自己写了一套，当初是用来架设Instagram网站。 做出来后，发现东西很好用，于是就开源了。 使用React需要什么准备？ 1. ES6 ES6的起源 1996年JavaScript提交给国际标准化组织ECMA，所以官方称呼这门语言为ECMAScript。 ECMAScript也需要不断的升级完善，2011年ECMAScript5.1版发布。 版本5的ECMAScript功能稳定，但基于nodejs的出现，ECMAScript觉得自己也得进步，于是在2015年发布了ECMAScript6，因为名字太长不好念，于是简写为ES6。 ES6的具体介绍详见 阮一峰大神的ES6入门 2. BABEL 当不使用BABEL，会有如下问题 各大浏览器老而弥坚。 浏览器更新速度快。 使用BABEL会解决这些问题 会使老浏览器焕发青春。 利用各种手段将ES6代码编译为ES5代码。 BABEL的问题：如何使BABEL自身自觉工作呢？ 3. webpack 使BABEL神不知鬼不觉进行工作的黑科技。 4. 然而以上三个不怎么重要，下面介绍一个 create-react-app 具有： 来自Facebook的黑科技 自动安装webpack 自动安装babel 直接开始用ES6编译开发 安装create-react-app： 先全局安装create-react-app - npm install -g create-react-app 创建create-react-app文件 - create-react-app &lt;file&gt; 下一章，将介绍如何使用react]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React概念</tag>
        <tag>ES6</tag>
        <tag>Babel</tag>
        <tag>Webpack</tag>
        <tag>create-react-app</tag>
      </tags>
  </entry>
</search>