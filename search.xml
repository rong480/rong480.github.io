<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Animation用法总结]]></title>
    <url>%2F2017%2F06%2F21%2FAnimation-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引入首先，说一下为什么要使用 Animation 呢？为什么我们不用 transition 呢？下面我来总结一下transition的局限性。 transition的使用是需要有事件触发的，所以无法在网页加载无事件时自动发生； transition只能用于定义开始状态和结束的状态，不能定义中间状态值，即要实现一个简单的逐帧动画是无法实现的； transition是一次性的属性，不能够反复发生，除非设置成多次触发，不能够自身循环； 一条transition的规则内，只能定义一个属性的状态变化及其相应的变化方式和时间轨迹，不能同时给两个属性同时赋值（除非同时给所有值赋值相同的变化方式和时间轨迹），即写法相对的繁冗。如下：1234567891011.transitiondemo&#123; width:200px; height: 200px; background: #f00; transition: 2s height,1s 1s width,3s background;&#125;.transitiondemo:hover&#123; width: 500px; height:600px; background: #0f0;&#125; transition里面的属性每条都需要单独来写，解释了transition里的第4条。这时，CSS3里的Animation就出来解决这些问题了。 Animation基本用法在body标签里创建个div，赋个类名叫animationdemo，然后写好他的初始样式：12345.animationdemo&#123; width:200px; height: 200px; background: #f00;&#125; 然后，要让他动画起来，首先，要给他一个动画名和持续时间：123.animationdemo:hover&#123; animation: 3s animatedemo;&#125; 这里面的 3s 是指这个动画持续的时间， animatedemo 则是我定义的动画名，现在需要设置动画过程，这里要引入一个创建动画的 @keyframes 规则：1234@keyframes animatedemo &#123; 50% &#123;background: #0f0&#125; 100% &#123;background: #00f&#125;&#125; @keyframes + 动画名{动画过程}，然后在动画过程部分，写上占动画时间百分比，修改的属性及属性值，动画会圆滑的过渡到你设置的位置。个人理解 ：此处加个写动画时间和百分数不是随意写的，现在市面的显示器，一般为60帧（即将一秒平分60份，每份16.666…667ms），所以设置动画时需要算一下帧数。组合起来，CSS内的代码是这样的：123456789101112.animationdemo&#123; width:200px; height: 200px; background: #f00;&#125;.animationdemo:hover&#123; animation: 3s animatedemo;&#125;@keyframes animatedemo &#123; 50% &#123;background: #0f0&#125; 100% &#123;background: #00f&#125;&#125; 当然，hover里面animation属性的写法是简写的，也可以写成这样：1234.animationdemo:hover&#123; animation-name: animatedemo; //动画名 animation-duration: 3s; //动画持续时间&#125; 现在，我们要挨个介绍animation里的属性了。 animation里的主要属性animation-delay这个animation的属性是： animation-delay 。它的属性值为 .. s(几秒)，指的是这个动画要延迟多长时间再进行。123.animationdemo:hover&#123; animation-delay: 1s; //动画延迟时间&#125; animation-iteration-count这个animation的属性是： animation-iteration-count 。它的属性值通常是数字和’infinite’，指的是这个动画要重复循环多少次，如果不设置此值，动画即进行一次结束，属性值设置为 infinite 后，即可让动画无限循环。123.animationdemo:hover&#123; animation-iteration-count: infinite; //动画循环次数&#125; animation-fill-mode这个animation的属性是： animation-fill-mode 。指动画结束那一瞬间停留的状态，默认值为 none，即回到动画没开始时的状态。该属性的属性值有以下几种：| 属性值 | 属性值解释 || :—: | :—: || none | 默认值，回到动画没开始的状态 || forwards | 动画停留在动画结束最后一帧的状态 || backwards | 动画停留在动画开始的第一帧的状态 || both | 根据animation-direction属性，轮流使用backwards和forwards |123.animationdemo:hover&#123; animation-fill-mode: both; //动画结束时停留的状态&#125; animation-direction这个animation属性是： animation-direction 。指动画循环播放时动画的播放方向，默认值为normal：即第一次动画时顺序播放，紧接着的下一个动画还是顺序播放，以此类推。该属性的属性值有以下几种：| 属性值 | 属性值解释 || :—: | :—: || normal | 默认值，第一次动画顺序播放，接着的动画都为顺序播放 || alternate | 第一次动画为顺序播放，接着下一个动画播放顺序与上一个动画顺序相反 || reverse | 第一次动画逆序播放，接下来的动画都为逆序播放 || alternate-reverse | 第一次动画为逆序播放，接着下一个动画播放顺序与上一个动画顺序相反 |123.animationdemo:hover&#123; animation-direction: alternate; //动画循环播放的播放方向&#125; animation-play-state这个animation的属性是： animation-play-state 。指动画循环时突然打断的状态，没有默认值，如不设置此值，默认的状态是，当打断动画，动画会自动回到动画的第一帧状态；当设置成paused值时，动画即使被打断，也停留在打断时的动画帧数，不会跳转到动画初始帧。该属性的属性值有以下几种：| 属性值 | 属性值解释 || :—: | :—: || running | 规定动画播放 || paused | 规定动画暂停 |1234567891011.animationdemo&#123; width:200px; height: 200px; background: #f00; animation: 3s 1s animatedemo infinite both alternate; animation-play-state: paused; //规定动画暂停&#125;.animationdemo:hover&#123; animation-play-state: running; //规定动画播放&#125; 可以看到，如果没有发生hover动作的时候，他是停留在paused状态下的，当hover上时，动画会进行，突然不hover时，动画不会回到第一帧，会暂停在当前动画进行的状态此属性通过js来控制，可以实现更多效果，主要为了突然停止动画，停在当前运行状态。 属性总结123456789 .animationdemo:hover&#123; animation-name: animatedemo; //动画名 animation-duration: 3s; //动画持续时间 animation-delay: 1s; //动画延迟时间 animation-iteration-count: infinite; //动画循环次数 animation-fill-mode: both; //动画结束时停留的状态 animation-direction: alternate; //动画循环播放的播放方向animation-play-state: paused; //规定动画暂停 &#125; 当然，以上的属性值都是可以简写成一行的，比如123456.animationdemo&#123; animation: 3s 1s animatedemo infinite both alternate paused;&#125;.animationdemo:hover&#123; animation-play-state: running;&#125; 以上，为animation里的主要属性，下面来介绍介绍keyframes。 @keyframes@keyframes 是用来定义动画的具体流程的，在里面可以写动画过程的各个状态值。格式如下：@keyframes 动画名{ 动画进行的百分比 {属性1：属性值；属性2：属性值；属性3…} 动画进行的百分比 {属性1：属性值；属性2：属性值；}}具体写法见下：12345@keyframes animatedemo &#123; //animatedemo为我设置的动画名 0% &#123;background: #f0f;width:300px;&#125; //属性1为background;属性2为width； 50% &#123;background: #0f0;&#125; //属性1为background；属性2没写，即回到元素该属性值的状态 100% &#123;background: #00f;&#125;&#125; 里面得0%可以用from代替，100%可以用to代替。12345@keyframes animatedemo &#123; //animatedemo为我设置的动画名 from &#123;background: #f0f;width:300px;&#125; //属性1为background;属性2为width； 50% &#123;background: #0f0;&#125; //属性1为background；属性2没写，即回到元素该属性值的状态 to &#123;background: #00f;&#125;&#125; 总结animation属性解决掉了transition局限性，更为好用。好的animation不止是设计的良苦用心，也是前端的细心和想象力。说了很多，但是想要做出好的效果还是很难的，这里感谢阮一峰的博客，菜鸟教程。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
        <tag>Animation</tag>
        <tag>样式</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2017%2F06%2F05%2F%E9%9D%A2%E8%AF%95html%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[HTMLHTML简介HTML]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-基础（三）]]></title>
    <url>%2F2017%2F04%2F24%2FReact-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先，生成新的react文件夹，还是要删除所有东西，只留index.js和logo.svg在index.js中创建新的项目12345678import React from 'react'import ReactDOM from 'react-dom'import App from './app.js'ReactDOM.render( &lt;App /&gt;, document.getElementById('root')) 再在同级文件夹内，创建app.js文件，在app.js文件内输入：123456789101112131415161718192021import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); this.state=&#123; times:'second' &#125; &#125; times(t)&#123; return(t) &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;hello world &#123;this.state.times&#125;&lt;/h1&gt; &lt;h1&gt;hello world &#123;this.times("3rd")&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125; 这样很好理解，现在说一个新的点，react中的事件 React事件比如在app里面添加一个按钮，让它具有onClick事件。在app.js中继续输入：1234567891011121314151617import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); &#125; clickHandler()&#123; alert("好玩么？") &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.clickHandler&#125;&gt;点击按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 这样，就实现了点击按钮，会弹出对话框的效果。我们再试试如下的按钮会实现吗？1234567891011121314151617181920212223242526272829import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); this.state=&#123; count:0 &#125; &#125; clickHandler()&#123; alert("好玩么？") &#125; addHandler()&#123; this.setState( &#123; count:this.state.count+1 &#125; ) &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.clickHandler&#125;&gt;点击按钮&lt;/button&gt; &lt;h2&gt;你刚刚点击了下面的按钮几次&lt;/h2&gt; &lt;button onClick=&#123;this.addHandler&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 当点击+1按钮时，console控制台会输出：Uncaught TypeError:Cannot read property ‘setState’ of null at addHandler到底是什么意思呢，简单翻译过来就是 未能捕获类型错误：不能找到在addHandler中的空具有的“setState”属性。翻译过来好像不像人话，简单解释一下，就是因为this的指向有问题，所以，会把this指向null。具体解释下：先看&lt;button onClick={this.addHandler}&gt;+1&lt;/button&gt;中的this的指向是没问题的，是指向App的，但是在点击时候，是按钮在调用这个对象（this.addHandler），但是，我们现在是个虚拟的 DOM Tree，它里面是没有真正的button，所以此时的button实际是null，那如何实现这样的绑定呢？ bind（）bind()方法，绑定方法，能改变一个对象的上下文环境,bind后面写着哪个对象，就会让前面的方法指向哪个对象在constructor中加入this.addHandler = this.addHandler.bind(this);绑定后，addHandler方法中的this就能正确的指向。 怎么能看到我们的state里的count值变了呢？此处，我们需要下载一个能测试react改变的状态值的小插件，我在chrome浏览器登陆谷歌网上应用商店，搜索React Developer Tools，并下载，就能实现看到react改变状态值了。 最好将所有调用的事件都bind()一下，这个是有必要的。 react里的for循环有的时候，我们需要将]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-基础（二）]]></title>
    <url>%2F2017%2F04%2F22%2FReact-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一回我们说到了react需要的准备，现在我们说说如何使用React吧。 react的前置概念 React有一个核心思想—组件化 有两个带头大哥—react和react-dom 一个基本运作方式—数据驱动视图 一个神秘卧底—jsx语法 三个主要帮手—state（状态）、props（属性）、refs（实例） 打杂小弟—声明周期 react的使用react的两个带头大哥和神秘卧底jsx这么说完是不是什么都看不明白，好，我们具体举例子，在gitbash中输入 $ create-react-app &lt;file&gt;创建好文件夹后，在文件夹内运行npm start，默认打开localhost：3000端口可以打开默认react页面。在创建的文件夹内的public内，用编译器打开index.html，我们发现这个html内，除了一个id=root的空div之外，剩下没什么有用的内容了，但是是什么驱动了react默认页面的呢？ 我们把src内除了logo.svg与index.js之外的其他文件都删除掉，并且把index.js内容都删除掉。现在再加载npm start是不是页面上就应该什么都没有了，然后我们要自己在index.js文件里写些语句来实现数据驱动视图 12345678910//首先引入两个重要的模块import React from 'react'import ReactDOM from 'react-dom'//react-dom 负责页面内容的控制ReactDOM.render( &lt;h1&gt;我是react生成的内容&lt;/h1&gt;, document.getElementById('root')) 再在bash命令行里输入”npm start”，就可以在localhost：3000端口表现页面了 react-dom这样页面就可以显示出“我是react生成的内容”，其中react-dom有两个参数： 渲染的内容； 渲染进页面的位置。jsx渲染进页面的内容的h1标签是怎么被实现出来的呢？这里我请出了神秘卧底 jsx，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。我们不需要一定使用jsx，但它有以下优点： JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化； 它是类型安全的，在编译过程中就能发现错误； 使用 JSX 编写模板更加简单快速。react刚刚使用react-dom了，但是为什么要先引入react这个模块呢？因为我使用了 jsx，如果不引入react模块，则无法读取jsx语句 react的组件我们引入新的概念：react中的组件现在刚刚输入的index.js中继续输入，当输入以下内容时：12345ReactDOM.render( &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt;, document.getElementById('root')) 页面是会报错，不会显示任何内容，主要原因是，react-dom的第一个参数：渲染的内容，必须是由一个闭合标签引入。以上的内容可以通过以下解决报错问题：1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt; &lt;/div&gt;, document.getElementById('root')) 这样就可以了，第一个参数必须是闭合的标签，且里面的内容也应该是闭合的标签。然后我们说react中的组件,先举个例子12345678910111213141516171819//自定义一个Ul组件class Ul extends React.Component&#123; render()&#123; return( &lt;ul&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;/ul&gt; )&#125; &#125;ReactDOM.render( &lt;div&gt; &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;Ul /&gt; &lt;/div&gt;, document.getElementById('root')) 如果引用react中的组件，必须先自定义个组件。具体操作为：class “Name” extends React.Component{render(){return(闭合的要渲染进去的内容)}} 在index.js中可以引入渲染中需要的css的。现在index.js先引入css文件：1import "./index.css" 渲染的时候就可以添加样式了。 插值可以是简单的表达式 123456789101112131415161718192021class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125; 渲染到html上就是：12342假的hello world下午8:00:51 但显示的时间仅是现在的时间，不能及时修改时间，我们暂且用这种想法试试呢？123456789101112131415161718192021222324class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; setInterval(()=&gt;&#123; this.state.time=(new Date()).toLocaleTimeString() &#125;,1000) &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125; 这样的写法也不会及时更改时间，永远不要直接修改state，如果要出现页面view的变化，要通过setState方法123setInterval(()=&gt;&#123; this.setState(&#123;time:(new Date()).toLocaleTimeString()&#125;) &#125;,1000) 这样显示的就是即时时间但都写在一个文件里，不太好，能不能通过引用组件呢？我们在index.js里写：1import Ul from './Ul.js' 为什么此处的Ul要大写呢？因为jsx语法中，当开头字母是小写的时候，即判定为element，也就是普通网页上的标签，首字母大写的，被定义为自定义组件标签。在同级创建个Ul.js文件可以把有关Ul组件的东西考到Ul.js里，一定要在Ul.js里引用react，并在最后抛出Ul组件则在Ul.js里写：12345678910111213141516171819202122232425262728import React from "react"class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; setInterval(()=&gt;&#123; this.setState(&#123;time:(new Date()).toLocaleTimeString()&#125;) &#125;,1000) &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125;export default Ul jsx并不是真正的HTML标签，而是虚拟的DOM Tree我们会发现，刚刚实现的网页，在浏览器上，对象里，有个div，既不在head标签内，也不再body标签内，而是单独的一个div，点开会发现，里面有个#shadow-root,这个东西就是个 虚拟的 DOM Tree，他是DOM结构的一个映射，一个影子。即在react一般不会在真实的DOM Tree里操作，一般是在虚拟的DOM Tree中实现，再投射在真实的DOM Tree。这里再说一下react厉害之处，它可以识别到真实的DOM Tree和虚拟的DOM Tree。比如刚刚的时间，原来使用的是把整个页面都重新刷新一遍，现在，只需要刷新时间这部分的内容就可以了。jsx中的{}插值的位置都很随意。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React基础</tag>
        <tag>react</tag>
        <tag>react-dom</tag>
        <tag>数据驱动视图</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 初识（一）]]></title>
    <url>%2F2017%2F04%2F18%2FReact-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[React是什么？ React.js（React）github上的原文解释是 A declarative, efficient, and flexible JavaScript library for building user interfaces.我个人翻译过来，一个 声明的，高效的，灵活的JavaScript库来构建用户界面。 React的起源React起源于Facebook的内部项目，因为该公司对市场上所有的JavaScript MVC框架，都不满意，于是他们就自己写了一套，当初是用来架设Instagram网站。做出来后，发现东西很好用，于是就开源了。 使用React需要什么准备？1. ES6 ES6的起源 1996年JavaScript提交给国际标准化组织ECMA，所以官方称呼这门语言为ECMAScript。 ECMAScript也需要不断的升级完善，2011年ECMAScript5.1版发布。 版本5的ECMAScript功能稳定，但基于nodejs的出现，ECMAScript觉得自己也得进步，于是在2015年发布了ECMAScript6，因为名字太长不好念，于是简写为ES6。 ES6的具体介绍详见 阮一峰大神的ES6入门 2. BABEL 当不使用BABEL，会有如下问题 各大浏览器老而弥坚。 浏览器更新速度快。 使用BABEL会解决这些问题 会使老浏览器焕发青春。 利用各种手段将ES6代码编译为ES5代码。 BABEL的问题：如何使BABEL自身自觉工作呢？ 3. webpack 使BABEL神不知鬼不觉进行工作的黑科技。 4. 然而以上三个不怎么重要，下面介绍一个create-react-app 具有： 来自Facebook的黑科技 自动安装webpack 自动安装babel 直接开始用ES6编译开发 安装create-react-app：先全局安装create-react-app - npm install -g create-react-app 创建create-react-app文件 - create-react-app &lt;file&gt; 下一章，将介绍如何使用react]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React概念</tag>
        <tag>ES6</tag>
        <tag>Babel</tag>
        <tag>Webpack</tag>
        <tag>create-react-app</tag>
      </tags>
  </entry>
</search>