<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iscroll.js 常用api]]></title>
    <url>%2F2017%2F07%2F05%2Fiscroll.js%20%E5%B8%B8%E7%94%A8api%2F</url>
    <content type="text"><![CDATA[欢迎使用 {小书匠}(xiaoshujiang)编辑器，您可以通过==设置==里的修改模板来改变新建文章的内容。]]></content>
      <categories>
        <category>JavaScript库</category>
        <category>iscroll</category>
      </categories>
      <tags>
        <tag>js库</tag>
        <tag>iscroll</tag>
        <tag>iscroll.js</tag>
        <tag>JavaScript库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustache.js 基础（三）]]></title>
    <url>%2F2017%2F07%2F04%2FmustacheJS-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[mustache的partials partials开始是以一个大于号“&gt;”开始的，{{&gt;partials}}。 partials在运行时渲染，而不是在编译时，所以递归的partials是可行的。要避免无限循环。 他们也继承了调用上下文，而在ERB中你可能会看到： &lt;%= partial :next_more, :start =&gt; start, :size =&gt; size %&gt; 但是在mustache里只要这样： {{&gt; next_more}}]]></content>
      <categories>
        <category>JavaScript库</category>
      </categories>
      <tags>
        <tag>js库</tag>
        <tag>JavaScript库</tag>
        <tag>mustache</tag>
        <tag>mustache.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustache.js 基础（二）]]></title>
    <url>%2F2017%2F07%2F04%2FmustacheJS-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[mustache的Sections（节） 根据上下文键值，节一次或者多次渲染出文本块。节以“#（pound ）”开始，以“/”结束。 比如{{#person}}开始一个person节，然后以{{/person}}结束它。两个标记之间的文本，被称为是该节的块。节的行为由键值决定。 false值和空列表 如果person的键不存在，或者存在并且有个值为：null、undefined、0、NaN、false、空字符串、空列表，则块不会被渲染。 当值是一个列表的时候，该块对列表中的每一项都进行一次渲染。块的环境在每次循环中，都会设置为列表中的当前项。以这种方式，我们可以循环把元素渲染到页面上。 举个例子： 在body内写入以下内容之后： 1234567891011121314151617181920212223242526&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; names:[ &#123;name:&quot;smith&quot;&#125;, &#123;name:&quot;billy&quot;&#125;, &#123;name:&quot;joe&quot;&#125;, &#123;name:&quot;mike&quot;&#125;, &#123;name:&quot;fez&quot;&#125; ] &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt; &#123;&#123;#names&#125;&#125; &lt;b&gt;&#123;&#123;name&#125;&#125;&lt;/b&gt; &lt;br/&gt; &#123;&#123;/names&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果就是： smith billy joe mike fez 当在一个字符串数组上循环时，一个“.”（点）可以被用来引用列表中的当前项。而以其他形式存储的数据，是无法通过“.”来循环渲染的。 举个例子： 12345678910111213141516171819202122&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; names:[ &quot;smith&quot;,&quot;billy&quot;,&quot;joe&quot;,&quot;mike&quot;,&quot;fez&quot; ] &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt; &#123;&#123;#names&#125;&#125; &lt;b&gt;&#123;&#123;.&#125;&#125;&lt;/b&gt; &lt;br/&gt; &#123;&#123;/names&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： smith billy joe mike fez 同上一个例子出来的效果一样。 如果一个区段变量是一个函数，它将在每次迭代列表中当前项的环境调用。 举个例子： 1234567891011121314151617181920212223242526272829&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; singers:[ &#123;firstname:&quot;smith&quot;,lastname:&quot;white&quot;&#125;, &#123;firstname:&quot;billy&quot;,lastname:&quot;black&quot;&#125;, &#123;firstname:&quot;joe&quot;,lastname:&quot;yeo&quot;&#125;, &#123;firstname:&quot;mike&quot;,lastname:&quot;bay&quot;&#125;, &#123;firstname:&quot;fez&quot;,lastname:&quot;fez&quot;&#125;, ], showname:function()&#123; return this.firstname+&quot;.&quot;+this.lastname &#125; &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt; &#123;&#123;#singers&#125;&#125; &lt;b&gt;&#123;&#123;showname&#125;&#125;&lt;/b&gt; &lt;br/&gt; &#123;&#123;/singers&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： smith.white billy.black joe.yeo mike.bay fez.fez 通过此方法，可以用mustache进行一次简单的过滤判断，然后渲染到页面上。再举个例子： 12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; scores:[ &#123;title:&apos;震惊&apos;,score:78&#125;, &#123;title:&apos;啊&apos;,score:50&#125;, &#123;title:&apos;哦&apos;,score:90&#125;, &#123;title:&apos;咦&apos;,score:23&#125;, &#123;title:&apos;嗯&apos;,score:46&#125;, &#123;title:&apos;呦&apos;,score:100&#125;, ], showscores:function()&#123; if(this.score&gt;70)&#123; return &quot;&lt;b&gt;&quot;+this.title+&quot;:&quot;+this.score+&quot;&lt;/b&gt;&lt;br/&gt;&quot;; &#125; else&#123; return; &#125; &#125; &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt; &#123;&#123;#scores&#125;&#125; &#123;&#123;&#123;showscores&#125;&#125;&#125; &#123;&#123;/scores&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： 震惊:78 哦:90 呦:100 总结一下以上代码踩坑经历： 首先，我的function里做了个判断，然后把符合的值传了出来，之前写的是： 12345678showscores:function()&#123; if(this.score&gt;70)&#123; return this.title+&quot;:&quot;+this.score; &#125; else&#123; return false; &#125; &#125; 然后template那里是这么写的： 123 &#123;&#123;#scores&#125;&#125;&lt;b&gt;&#123;&#123;showscores&#125;&#125;&lt;/b&gt;&lt;br/&gt;&#123;&#123;/scores&#125;&#125; 结果，出来的效果是这样的： 震惊:78 false 哦:90 false false 呦:100 很明显这不是我想要的效果，于是，我把else里的return false改成return；了，结果出来的结果是： 震惊:78 哦:90 呦:100 结果中间return；的位置，还是用空来代替了，还是执行了&lt;br/&gt;标签，于是我想到了用三个胡子写法。就是最终实现效果的写法。 函数 如果一个节的键值是一个函数，那么这个键值就会被作为该节的第一个参数，被原义的文本块调用，且不会被渲染。第二个参数是一个特殊的渲染函数，它使用了当前视图作为视图参数。它是在当前视图对象的上下文中调用的。 还是举个例子： 12345678910111213141516171819202122&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; name: &quot;Rong&quot;, bold: function() &#123; return function(text, render) &#123; return &quot;&lt;b&gt;&quot; + render(text) + &quot;&lt;/b&gt;&quot;; &#125; &#125; &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt; &#123;&#123;#bold&#125;&#125; Hi &#123;&#123;name&#125;&#125; &#123;&#123;/bold&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： Hi Rong mustache的Inverted Sections（反转节） 一个反转节用{{^section}}取代了{{#section}}来开头，反转节只有在这个标签内的值为null、undefined、false、非法写法、空列表的时候才会渲染。 继续举个例子： 123456789101112131415161718&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; name:[] &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt;&#123;&#123;#name&#125;&#125;如果不为空，显示你&#123;&#123;/name&#125;&#125;&#123;&#123;^name&#125;&#125;如果为空，显示你&#123;&#123;/name&#125;&#125;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： 如果为空，显示你 mustache的注释 注释是以一个感叹号&quot;!&quot;开始，然后里面的内容就会被忽略。以下为测试： 1234567891011121314151617&lt;div class=&quot;namecols&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/mustache.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var namecols=&#123; name:[“aa&quot;,&quot;bb&quot;] &#125;&lt;/script&gt;&lt;script id=&quot;tpl-namecolsType&quot; type=&quot;x-tmpl-mustache&quot;&gt;&lt;p&gt;what is &#123;&#123;! name&#125;&#125;&lt;/p&gt;&lt;/script&gt;&lt;script&gt; var tplNamecolsType = $(&apos;#tpl-namecolsType&apos;).html(); Mustache.parse(tplNamecolsType); var rendered3 = Mustache.render(tplNamecolsType, namecols); $(&apos;.namecols&apos;).html(rendered3);&lt;/script&gt; 渲染出来的效果是： what is 下次我们继续来说mustache.js基础。]]></content>
      <categories>
        <category>JavaScript库</category>
      </categories>
      <tags>
        <tag>js库</tag>
        <tag>JavaScript库</tag>
        <tag>mustache</tag>
        <tag>mustache.js</tag>
        <tag>section</tag>
        <tag>inverted sections</tag>
        <tag>mustache注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustache.js 初识（一）]]></title>
    <url>%2F2017%2F06%2F26%2FmustacheJS-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[mustache.js 介绍 出于mustache在github上有好多，我此次学习的是janl/mustache， language为JavaScript的那个。 mustache.js概念 官方文档第一句： What could be more logical awesome than no logic at all? 我翻译不出来，简单就是说，还有什么比毫无逻辑更可怕。 然后作者第一句解释mustache是什么，是这样写的： mustache.js is an implementation of the mustache template system in JavaScript. 我简单翻译过来：mustahce是一个以JavaScript语言实现的mustache模板系统执行者。 然而好像没法看懂啊，这好像提取不出来什么有用的信息啊！ 紧接着这段重要了啊！！！知识点！！！ Mustache is a logic-less template syntax. It can be used for HTML, config files, source code - anything. It works by expanding tags in a template using values provided in a hash or object. 我简单翻译一下： Mustache是一个少逻辑的模板语法。它可以用于HTML，配置文件，源代码等任何东西。它通过散列或对象提供的值来扩展模块的标签。 重点词有：少逻辑，模板，可以用于任何东西，通过散列或者对象来扩展标签。 至此，mustache.js解释出来了。下面我们来看看mustache.js如何使用？ mustache引用 当要使用mustache.js时，需要先引入mustache.js文件到需要用的页面里去。如果是模块打包生成的项目，需要 npm install mustache 引入了mustache之后，我们就要看如何使用mustache了。 mustache 使用 mustache使用 先举个例子，先定义一个对象 1234567var view = &#123; title: "Joe", calc: function () &#123; return 2 + 4; &#125;&#125;;var output = Mustache.render("&#123;&#123;title&#125;&#125; spends &#123;&#123;calc&#125;&#125;", view); 在示例中，Mustache.render内有两个参数，第一个参数为mustache模板，第二个为view对象，里面装着用来渲染进模板的数据或者代码。 mustache的API mustache里的api有： 12345678910Mustache.render( template : String, //模板 view : Object, //渲染进模板的数据 partials : Object //(可有可无，之后再谈)) =&gt; StringMustache.parse( template : String, //模板 tags = ['&#123;&#123;' , '&#125;&#125;'] : Tags, //放入模板的数据) =&gt; Stringinterface Tags [String,String] mustache的Templates 一个mustache的模板是一个包含任何数量的mustache标签的字符串。标签是被两个胡子括号（即“{{}}”）包裹起来的。例如：{{person}}是一个标签，{{#person}}也是一个标签。在上面两个例子中，我们都将person称作是标签的键。在mustache.js可用标签的几种类型，见以下描述： 有几种方法可以用来加载模板，并把它们提交给mustache.js，分为以下两种： 包括模板 如果你需要在静态页面中添加为了动态数据的模板，你可以直接在静态页面中写入模板，就不用单独加载模板了。以下有个使用jQuery的小例子： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body onload="loadUser()"&gt;&lt;div id="target"&gt;Loading...&lt;/div&gt;&lt;script id="template" type="x-tmpl-mustache"&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456function loadUser() &#123; var template = $('#template').html(); Mustache.parse(template); // optional, speeds up future uses var rendered = Mustache.render(template, &#123;name: "Luke"&#125;); $('#target').html(rendered);&#125; 实现的效果就是，先是页面加载，当页面加载完成后，页面渲染出Hello Luke！ 加载外部模板 如果你把模板放到一个单独文件内，你可以异步加载它，并在获取数据后执行渲染。以下有另一个使用jQuery的小例子： 123456function loadUser() &#123; $.get('template.mst', function(template) &#123; var rendered = Mustache.render(template, &#123;name: "Luke"&#125;); $('#target').html(rendered); &#125;);&#125; mustache的变量 最基本的标记类型是一个简单的变量，比如一个{{name}}标签渲染的就是上下文中键值为name的内容，如果没有这样的键值，就什么都不会渲染。 默认的情况下，所有的变量都是转义的HTML，如果你想渲染非转义的HTML，就使用三个胡子括号包起来，也可以使用&quot;&amp;&quot;符号来渲染非转义的HTML。我们下面举个例子来说明上面的情况 1234567891011&lt;div class="three-mustache"&gt;&lt;/div&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/mustache.min.js"&gt;&lt;/script&gt;&lt;script src="js/data.js"&gt;&lt;/script&gt;&lt;script&gt; var view = &#123; namethree:"&lt;strong&gt;what&lt;/strong&gt;" &#125;; var output=Mustache.render("&#123;&#123;namethree&#125;&#125;", view); $('.three-mustache').html(output);&lt;/script&gt; 这么写之后，页面会显示如下这样的效果： &lt;strong&gt;what&lt;/strong&gt; 这样并没有实现我想加粗的效果啊，虽然加粗很容易，但是我现在就想让他加粗，于是，试了试三个胡子写法，如下： 1234567891011&lt;div class="three-mustache"&gt;&lt;/div&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/mustache.min.js"&gt;&lt;/script&gt;&lt;script src="js/data.js"&gt;&lt;/script&gt;&lt;script&gt; var view = &#123; namethree:"&lt;strong&gt;what&lt;/strong&gt;" &#125;; var output=Mustache.render("&#123;&#123;&#123;namethree&#125;&#125;&#125;", view); $('.three-mustache').html(output);&lt;/script&gt; 页面显示如下效果： what 很好，达到我们想要的了，现在再测试以下这么写会有什么效果： 1234567891011&lt;div class="three-mustache"&gt;&lt;/div&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/mustache.min.js"&gt;&lt;/script&gt;&lt;script src="js/data.js"&gt;&lt;/script&gt;&lt;script&gt; var view = &#123; namethree:"&lt;strong&gt;what&lt;/strong&gt;" &#125;; var output=Mustache.render("&#123;&#123;&amp;namethree&#125;&#125;", view); $('.three-mustache').html(output);&lt;/script&gt; 测试出来的显示如下效果： what 最后，我们试一个特别神奇的测试，如下： 1234567891011&lt;div class="three-mustache"&gt;&lt;/div&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/mustache.min.js"&gt;&lt;/script&gt;&lt;script src="js/data.js"&gt;&lt;/script&gt;&lt;script&gt; var view = &#123; namethree:"&lt;strong&gt;what&lt;/strong&gt;" &#125;; var output=Mustache.render("&#123;&#123;=&lt;% %&gt;=&#125;&#125;&#123;&#123;namethree&#125;&#125;&lt;%=&#123;&#123; &#125;&#125;=%&gt;", view); $('.three-mustache').html(output);&lt;/script&gt; 测试出来的显示如下效果： {{namethree}} 是不是很神秘，今天就写到这，下次我们来说mustache.js基础篇。]]></content>
      <categories>
        <category>JavaScript库</category>
      </categories>
      <tags>
        <tag>js库</tag>
        <tag>JavaScript库</tag>
        <tag>mustache</tag>
        <tag>mustache.js</tag>
        <tag>logic-less</tag>
        <tag>API</tag>
        <tag>Template</tag>
        <tag>Variables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TweenJS 初识（一）]]></title>
    <url>%2F2017%2F06%2F21%2FTweenJS-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[TweenJS介绍 什么是TweenJS 在github上，Tweenjs是这么介绍自己的： TweenJS is a simple tweening library for use in Javascript. It was developed to integrate well with the EaselJS library, but is not dependent on or specific to it (though it uses the same Ticker and Event classes by default). It supports tweening of both numeric object properties &amp; CSS style properties. 翻译一下：Tweenjs是一个使用JavaScript的简单的动画库。它被开发为了与EaselJS更好的组合使用，但是它不依赖于EaselJS也不特定于EaselJS（尽管它默认使用相同的代码和事件的类），它接受数字对象属性和CSS样式属性的赋值。 从上面我们提取关键词：js库，基于EaselJS但不依赖于它，接受数字对象属性和CSS样式属性赋值。 有点容易理解了，下面试试怎么使用它。 第一次使用TweenJS 简单做个小canvas，首先，把html页面搭好，在里面写好600×600大小的canvas，赋个id为canvas。 然后，引入Tween.js文件 1&lt;script src="js/Tween.js"&gt;&lt;/script&gt; 引入Tween.js文件后，就可以使用TweenJS里的东西了。 在这段代码之前，先引入个概念，叫window.requestAnimationFrame(),MDN上对它进行了解释： The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes as an argument a callback to be invoked before the repaint. 翻译一下：这个window.requestAnimationFrame()的方法告诉浏览器你想要执行一个动画了，并且浏览器告知一个特殊的函数在下一次动画来临前更新画面。这个方法是传递给requestAnimationFrame()一个回调函数。 方法有点类似于setTimeout()。但不同是这个方法是专门为动画提供的API。 123456789101112131415161718&lt;script type="text/javascript"&gt; var canvas = document.getElementById('canvas'); //找到canvas var ctx = canvas.getContext('2d'); //定义canvas为2d效果绘制 var position = &#123; x: 100, y: 100 &#125;; //定义初始位置坐标 var tween = new TWEEN.Tween(position) //实例化一个对象tween，定位作为值传入 .to(&#123; x: 400,y:400 &#125;, 1000) //目标位置坐标，定义时间为1秒钟 .onUpdate(function()&#123; //在修改时，执行回调函数 ctx.fillStyle = 'rgba(150, 23, 207, 0.41)'; //给canvas里小元素赋颜色 ctx.fillRect(position.x,position.y,4,4); //让他在canvas上画4*4的小方块，位置在定义的位置坐标上 &#125;) .start(); //让Tween开始 function animate(time) &#123; //定义一个动画函数 window.requestAnimationFrame(animate); //把animate作为回调函数传给requestAnimationFrame()方法 TWEEN.update(time); //调用TWEEN.update()方法，实现平滑动画效果 &#125; animate(); //执行动画函数&lt;/script&gt; 实现的效果应该是从canvas上的（100，100）坐标位置开始，一串紫色小方块直到（400，400）坐标位置为止。 这就是我写的第一个基于TweenJS的第一个效果。]]></content>
      <categories>
        <category>JavaScript库</category>
      </categories>
      <tags>
        <tag>js库</tag>
        <tag>JavaScript库</tag>
        <tag>Tween</tag>
        <tag>TweenJS</tag>
        <tag>window.requestAnimationFrame()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animation用法总结]]></title>
    <url>%2F2017%2F06%2F21%2FAnimation-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[引入 首先，说一下为什么要使用 Animation 呢？为什么我们不用 transition 呢？下面我来总结一下transition的局限性。 transition的使用是需要有事件触发的，所以无法在网页加载无事件时自动发生； transition只能用于定义开始状态和结束的状态，不能定义中间状态值，即要实现一个简单的逐帧动画是无法实现的； transition是一次性的属性，不能够反复发生，除非设置成多次触发，不能够自身循环； 一条transition的规则内，只能定义一个属性的状态变化及其相应的变化方式和时间轨迹，不能同时给两个属性同时赋值（除非同时给所有值赋值相同的变化方式和时间轨迹），即写法相对的繁冗。如下： 1234567891011.transitiondemo&#123; width:200px; height: 200px; background: #f00; transition: 2s height,1s 1s width,3s background;&#125;.transitiondemo:hover&#123; width: 500px; height:600px; background: #0f0;&#125; transition里面的属性每条都需要单独来写，解释了transition里的第4条。 这时，CSS3里的Animation就出来解决这些问题了。 Animation 基本用法 在body标签里创建个div，赋个类名叫animationdemo，然后写好他的初始样式： 12345.animationdemo&#123; width:200px; height: 200px; background: #f00;&#125; 然后，要让他动画起来，首先，要给他一个动画名和持续时间： 123.animationdemo:hover&#123; animation: 3s animatedemo;&#125; 这里面的 3s 是指这个动画持续的时间， animatedemo 则是我定义的动画名，现在需要设置动画过程，这里要引入一个创建动画的 @keyframes 规则： 1234@keyframes animatedemo &#123; 50% &#123;background: #0f0&#125; 100% &#123;background: #00f&#125;&#125; @keyframes + 动画名{动画过程}，然后在动画过程部分，写上占动画时间百分比，修改的属性及属性值，动画会圆滑的过渡到你设置的位置。 个人理解 ：此处加个写动画时间和百分数不是随意写的，现在市面的显示器，一般为60帧（即将一秒平分60份，每份16.666...667ms），所以设置动画时需要算一下帧数。 组合起来，CSS内的代码是这样的： 123456789101112.animationdemo&#123; width:200px; height: 200px; background: #f00;&#125;.animationdemo:hover&#123; animation: 3s animatedemo;&#125;@keyframes animatedemo &#123; 50% &#123;background: #0f0&#125; 100% &#123;background: #00f&#125;&#125; 当然，hover里面animation属性的写法是简写的，也可以写成这样： 1234.animationdemo:hover&#123; animation-name: animatedemo; /*动画名*/ animation-duration: 3s; /*动画持续时间*/&#125; 现在，我们要挨个介绍animation里的属性了。 animation里的主要属性 animation-delay 这个animation的属性是： animation-delay 。它的属性值为 .. s(几秒)，指的是这个动画要延迟多长时间再进行。 123.animationdemo:hover&#123; animation-delay: 1s; /*动画延迟时间*/&#125; animation-iteration-count 这个animation的属性是： animation-iteration-count 。它的属性值通常是数字和'infinite'，指的是这个动画要重复循环多少次，如果不设置此值，动画即进行一次结束，属性值设置为 infinite 后，即可让动画无限循环。 123.animationdemo:hover&#123; animation-iteration-count: infinite; /*动画循环次数*/&#125; animation-fill-mode 这个animation的属性是： animation-fill-mode 。指动画结束那一瞬间停留的状态，默认值为 none，即回到动画没开始时的状态。 该属性的属性值有以下几种： 属性值 属性值解释 none 默认值，回到动画没开始的状态 forwards 动画停留在动画结束最后一帧的状态 backwards 动画停留在动画开始的第一帧的状态 both 根据animation-direction属性，轮流使用backwards和forwards 123.animationdemo:hover&#123; animation-fill-mode: both; /*动画结束时停留的状态*/&#125; animation-direction 这个animation属性是： animation-direction 。指动画循环播放时动画的播放方向，默认值为normal：即第一次动画时顺序播放，紧接着的下一个动画还是顺序播放，以此类推。 该属性的属性值有以下几种： 属性值 属性值解释 normal 默认值，第一次动画顺序播放，接着的动画都为顺序播放 alternate 第一次动画为顺序播放，接着下一个动画播放顺序与上一个动画顺序相反 reverse 第一次动画逆序播放，接下来的动画都为逆序播放 alternate-reverse 第一次动画为逆序播放，接着下一个动画播放顺序与上一个动画顺序相反 123.animationdemo:hover&#123; animation-direction: alternate; /*动画循环播放的播放方向*/&#125; animation-play-state 这个animation的属性是： animation-play-state 。指动画循环时突然打断的状态，没有默认值，如不设置此值，默认的状态是，当打断动画，动画会自动回到动画的第一帧状态；当设置成paused值时，动画即使被打断，也停留在打断时的动画帧数，不会跳转到动画初始帧。 该属性的属性值有以下几种： 属性值 属性值解释 running 规定动画播放 paused 规定动画暂停 1234567891011.animationdemo&#123; width:200px; height: 200px; background: #f00; animation: 3s 1s animatedemo infinite both alternate; animation-play-state: paused; /*规定动画暂停*/&#125;.animationdemo:hover&#123; animation-play-state: running; /*规定动画播放*/&#125; 可以看到，如果没有发生hover动作的时候，他是停留在paused状态下的，当hover上时，动画会进行，突然不hover时，动画不会回到第一帧，会暂停在当前动画进行的状态 此属性通过js来控制，可以实现更多效果，主要为了突然停止动画，停在当前运行状态。 属性总结 123456789 .animationdemo:hover&#123; animation-name: animatedemo; /*动画名*/ animation-duration: 3s; /*动画持续时间*/ animation-delay: 1s; /*动画延迟时间*/ animation-iteration-count: infinite; /*动画循环次数*/ animation-fill-mode: both; /*动画结束时停留的状态*/ animation-direction: alternate; /*动画循环播放的播放方向*/animation-play-state: paused; /*规定动画暂停*/ &#125; 当然，以上的属性值都是可以简写成一行的，比如 123456.animationdemo&#123; animation: 3s 1s animatedemo infinite both alternate paused;&#125;.animationdemo:hover&#123; animation-play-state: running;&#125; 以上，为animation里的主要属性，下面来介绍介绍keyframes。 @keyframes @keyframes 是用来定义动画的具体流程的，在里面可以写动画过程的各个状态值。格式如下： @keyframes 动画名{ 动画进行的百分比 {属性1：属性值；属性2：属性值；属性3...} 动画进行的百分比 {属性1：属性值；属性2：属性值；} } 具体写法见下： 12345@keyframes animatedemo &#123; /*animatedemo为我设置的动画名*/ 0% &#123;background: #f0f;width:300px;&#125; /*属性1为background;属性2为width；*/ 50% &#123;background: #0f0;&#125; /*属性1为background；属性2没写，即回到元素该属性值的状态*/ 100% &#123;background: #00f;&#125;&#125; 里面得0%可以用from代替，100%可以用to代替。 12345@keyframes animatedemo &#123; /*animatedemo为我设置的动画名*/ from &#123;background: #f0f;width:300px;&#125; /*属性1为background;属性2为width；*/ 50% &#123;background: #0f0;&#125; /*属性1为background；属性2没写，即回到元素该属性值的状态*/ to &#123;background: #00f;&#125;&#125; 总结 animation属性解决掉了transition局限性，更为好用。 好的animation不止是设计的良苦用心，也是前端的细心和想象力。 说了很多，但是想要做出好的效果还是很难的，这里感谢阮一峰的博客，菜鸟教程。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
        <tag>Animation</tag>
        <tag>样式</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2017%2F06%2F05%2F%E9%9D%A2%E8%AF%95html%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[HTML HTML简介 HTML]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-基础（三）]]></title>
    <url>%2F2017%2F04%2F24%2FReact-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先，生成新的react文件夹，还是要删除所有东西，只留index.js和logo.svg 在index.js中创建新的项目 12345678import React from 'react'import ReactDOM from 'react-dom'import App from './app.js'ReactDOM.render( &lt;App /&gt;, document.getElementById('root')) 再在同级文件夹内，创建app.js文件，在app.js文件内输入： 123456789101112131415161718192021import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); this.state=&#123; times:'second' &#125; &#125; times(t)&#123; return(t) &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;hello world &#123;this.state.times&#125;&lt;/h1&gt; &lt;h1&gt;hello world &#123;this.times("3rd")&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125; 这样很好理解，现在说一个新的点，react中的事件 React事件 比如在app里面添加一个按钮，让它具有onClick事件。在app.js中继续输入： 1234567891011121314151617import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); &#125; clickHandler()&#123; alert("好玩么？") &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.clickHandler&#125;&gt;点击按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 这样，就实现了点击按钮，会弹出对话框的效果。 我们再试试如下的按钮会实现吗？ 1234567891011121314151617181920212223242526272829import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); this.state=&#123; count:0 &#125; &#125; clickHandler()&#123; alert("好玩么？") &#125; addHandler()&#123; this.setState( &#123; count:this.state.count+1 &#125; ) &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.clickHandler&#125;&gt;点击按钮&lt;/button&gt; &lt;h2&gt;你刚刚点击了下面的按钮几次&lt;/h2&gt; &lt;button onClick=&#123;this.addHandler&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 当点击+1按钮时，console控制台会输出：&lt;font color=red&gt;Uncaught TypeError:Cannot read property 'setState' of null at addHandler&lt;/font&gt; 到底是什么意思呢，简单翻译过来就是 未能捕获类型错误：不能找到在addHandler中的空具有的“setState”属性。翻译过来好像不像人话，简单解释一下，就是因为this的指向有问题，所以，会把this指向null。具体解释下： 先看&lt;button onClick={this.addHandler}&gt;+1&lt;/button&gt;中的this的指向是没问题的，是指向App的，但是在点击时候，是按钮在调用这个对象（this.addHandler），但是，我们现在是个虚拟的 DOM Tree，它里面是没有真正的button，所以此时的button实际是null，那如何实现这样的绑定呢？ bind（） bind()方法，绑定方法，能改变一个对象的上下文环境,bind后面写着哪个对象，就会让前面的方法指向哪个对象 在constructor中加入this.addHandler = this.addHandler.bind(this); 绑定后，addHandler方法中的this就能正确的指向。 怎么能看到我们的state里的count值变了呢？此处，我们需要下载一个能测试react改变的状态值的小插件，我在chrome浏览器登陆谷歌网上应用商店，搜索React Developer Tools，并下载，就能实现看到react改变状态值了。 最好将所有调用的事件都bind()一下，这个是有必要的。 react里的for循环 有的时候，我们需要将]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-基础（二）]]></title>
    <url>%2F2017%2F04%2F22%2FReact-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一回我们说到了react需要的准备，现在我们说说如何使用React吧。 react的前置概念 React有一个核心思想---组件化 有两个带头大哥---react和react-dom 一个基本运作方式---数据驱动视图 一个神秘卧底---jsx语法 三个主要帮手---state（状态）、props（属性）、refs（实例） 打杂小弟---声明周期 react的使用 react的两个带头大哥和神秘卧底jsx 这么说完是不是什么都看不明白，好，我们具体举例子，在gitbash中输入 $ create-react-app &lt;file&gt; 创建好文件夹后，在文件夹内运行npm start，默认打开localhost：3000端口可以打开默认react页面。 在创建的文件夹内的public内，用编译器打开index.html，我们发现这个html内，除了一个id=root的空div之外，剩下没什么有用的内容了，但是是什么驱动了react默认页面的呢？ 我们把src内除了logo.svg与index.js之外的其他文件都删除掉，并且把index.js内容都删除掉。 现在再加载npm start是不是页面上就应该什么都没有了，然后我们要自己在index.js文件里写些语句来实现数据驱动视图 12345678910//首先引入两个重要的模块import React from 'react'import ReactDOM from 'react-dom'//react-dom 负责页面内容的控制ReactDOM.render( &lt;h1&gt;我是react生成的内容&lt;/h1&gt;, document.getElementById('root')) 再在bash命令行里输入&quot;npm start&quot;，就可以在localhost：3000端口表现页面了 react-dom 这样页面就可以显示出“我是react生成的内容”，其中react-dom有两个参数： 渲染的内容； 渲染进页面的位置。 jsx 渲染进页面的内容的h1标签是怎么被实现出来的呢？ 这里我请出了神秘卧底 jsx，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 我们不需要一定使用jsx，但它有以下优点： JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化； 它是类型安全的，在编译过程中就能发现错误； 使用 JSX 编写模板更加简单快速。 react 刚刚使用react-dom了，但是为什么要先引入react这个模块呢？因为我使用了 jsx，如果不引入react模块，则无法读取jsx语句 react的组件 我们引入新的概念：react中的组件 现在刚刚输入的index.js中继续输入，当输入以下内容时： 12345ReactDOM.render( &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt;, document.getElementById('root')) 页面是会报错，不会显示任何内容，主要原因是，react-dom的第一个参数：渲染的内容，必须是由一个闭合标签引入。以上的内容可以通过以下解决报错问题： 1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt; &lt;/div&gt;, document.getElementById('root')) 这样就可以了，第一个参数必须是闭合的标签，且里面的内容也应该是闭合的标签。 然后我们说react中的组件,先举个例子 12345678910111213141516171819//自定义一个Ul组件class Ul extends React.Component&#123; render()&#123; return( &lt;ul&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;/ul&gt; )&#125; &#125;ReactDOM.render( &lt;div&gt; &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;Ul /&gt; &lt;/div&gt;, document.getElementById('root')) 如果引用react中的组件，必须先自定义个组件。 具体操作为：class “Name” extends React.Component{render(){return(闭合的要渲染进去的内容)}} 在index.js中可以引入渲染中需要的css的。 现在index.js先引入css文件： 1import "./index.css" 渲染的时候就可以添加样式了。 插值可以是简单的表达式 123456789101112131415161718192021class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125; 渲染到html上就是： 12342假的hello world下午8:00:51 但显示的时间仅是现在的时间，不能及时修改时间，我们暂且用这种想法试试呢？ 123456789101112131415161718192021222324class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; setInterval(()=&gt;&#123; this.state.time=(new Date()).toLocaleTimeString() &#125;,1000) &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125; 这样的写法也不会及时更改时间，永远不要直接修改state，如果要出现页面view的变化，要通过setState方法 123setInterval(()=&gt;&#123; this.setState(&#123;time:(new Date()).toLocaleTimeString()&#125;) &#125;,1000) 这样显示的就是即时时间 但都写在一个文件里，不太好，能不能通过引用组件呢？ 我们在index.js里写： 1import Ul from './Ul.js' 为什么此处的Ul要大写呢？ 因为jsx语法中，当开头字母是小写的时候，即判定为element，也就是普通网页上的标签，首字母大写的，被定义为自定义组件标签。 在同级创建个Ul.js文件 可以把有关Ul组件的东西考到Ul.js里，一定要在Ul.js里引用react，并在最后抛出Ul组件 则在Ul.js里写： 12345678910111213141516171819202122232425262728import React from "react"class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; setInterval(()=&gt;&#123; this.setState(&#123;time:(new Date()).toLocaleTimeString()&#125;) &#125;,1000) &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125;export default Ul jsx并不是真正的HTML标签，而是虚拟的DOM Tree 我们会发现，刚刚实现的网页，在浏览器上，对象里，有个div，既不在head标签内，也不再body标签内，而是单独的一个div，点开会发现，里面有个#shadow-root,这个东西就是个 虚拟的 DOM Tree，他是DOM结构的一个映射，一个影子。 即在react一般不会在真实的DOM Tree里操作，一般是在虚拟的DOM Tree中实现，再投射在真实的DOM Tree。 这里再说一下react厉害之处，它可以识别到真实的DOM Tree和虚拟的DOM Tree。比如刚刚的时间，原来使用的是把整个页面都重新刷新一遍，现在，只需要刷新时间这部分的内容就可以了。 jsx中的{}插值的位置都很随意。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React基础</tag>
        <tag>react</tag>
        <tag>react-dom</tag>
        <tag>数据驱动视图</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 初识（一）]]></title>
    <url>%2F2017%2F04%2F18%2FReact-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[React是什么？ React.js（React）github上的原文解释是 A declarative, efficient, and flexible JavaScript library for building user interfaces. 我个人翻译过来，一个 声明的，高效的，灵活的JavaScript库来构建用户界面。 React的起源 React起源于Facebook的内部项目，因为该公司对市场上所有的JavaScript MVC框架，都不满意，于是他们就自己写了一套，当初是用来架设Instagram网站。 做出来后，发现东西很好用，于是就开源了。 使用React需要什么准备？ 1. ES6 ES6的起源 1996年JavaScript提交给国际标准化组织ECMA，所以官方称呼这门语言为ECMAScript。 ECMAScript也需要不断的升级完善，2011年ECMAScript5.1版发布。 版本5的ECMAScript功能稳定，但基于nodejs的出现，ECMAScript觉得自己也得进步，于是在2015年发布了ECMAScript6，因为名字太长不好念，于是简写为ES6。 ES6的具体介绍详见 阮一峰大神的ES6入门 2. BABEL 当不使用BABEL，会有如下问题 各大浏览器老而弥坚。 浏览器更新速度快。 使用BABEL会解决这些问题 会使老浏览器焕发青春。 利用各种手段将ES6代码编译为ES5代码。 BABEL的问题：如何使BABEL自身自觉工作呢？ 3. webpack 使BABEL神不知鬼不觉进行工作的黑科技。 4. 然而以上三个不怎么重要，下面介绍一个 create-react-app 具有： 来自Facebook的黑科技 自动安装webpack 自动安装babel 直接开始用ES6编译开发 安装create-react-app： 先全局安装create-react-app - npm install -g create-react-app 创建create-react-app文件 - create-react-app &lt;file&gt; 下一章，将介绍如何使用react]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React概念</tag>
        <tag>ES6</tag>
        <tag>Babel</tag>
        <tag>Webpack</tag>
        <tag>create-react-app</tag>
      </tags>
  </entry>
</search>