<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试html部分]]></title>
    <url>%2F2017%2F06%2F05%2F%E9%9D%A2%E8%AF%95html%E9%83%A8%E5%88%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[React-基础（三）]]></title>
    <url>%2F2017%2F04%2F24%2FReact-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先，生成新的react文件夹，还是要删除所有东西，只留index.js和logo.svg在index.js中创建新的项目12345678import React from 'react'import ReactDOM from 'react-dom'import App from './app.js'ReactDOM.render( &lt;App /&gt;, document.getElementById('root')) 再在同级文件夹内，创建app.js文件，在app.js文件内输入：123456789101112131415161718192021import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); this.state=&#123; times:'second' &#125; &#125; times(t)&#123; return(t) &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;hello world &#123;this.state.times&#125;&lt;/h1&gt; &lt;h1&gt;hello world &#123;this.times("3rd")&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125; 这样很好理解，现在说一个新的点，react中的事件 React事件比如在app里面添加一个按钮，让它具有onClick事件。在app.js中继续输入：1234567891011121314151617import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); &#125; clickHandler()&#123; alert("好玩么？") &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.clickHandler&#125;&gt;点击按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 这样，就实现了点击按钮，会弹出对话框的效果。我们再试试如下的按钮会实现吗？1234567891011121314151617181920212223242526272829import React from 'react'export default class App extends React.Component&#123; constructor()&#123; super(); this.state=&#123; count:0 &#125; &#125; clickHandler()&#123; alert("好玩么？") &#125; addHandler()&#123; this.setState( &#123; count:this.state.count+1 &#125; ) &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.clickHandler&#125;&gt;点击按钮&lt;/button&gt; &lt;h2&gt;你刚刚点击了下面的按钮几次&lt;/h2&gt; &lt;button onClick=&#123;this.addHandler&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 当点击+1按钮时，console控制台会输出：Uncaught TypeError:Cannot read property ‘setState’ of null at addHandler到底是什么意思呢，简单翻译过来就是 未能捕获类型错误：不能找到在addHandler中的空具有的“setState”属性。翻译过来好像不像人话，简单解释一下，就是因为this的指向有问题，所以，会把this指向null。具体解释下：先看&lt;button onClick={this.addHandler}&gt;+1&lt;/button&gt;中的this的指向是没问题的，是指向App的，但是在点击时候，是按钮在调用这个对象（this.addHandler），但是，我们现在是个虚拟的 DOM Tree，它里面是没有真正的button，所以此时的button实际是null，那如何实现这样的绑定呢？ bind（）方法，绑定方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[React-基础（二）]]></title>
    <url>%2F2017%2F04%2F22%2FReact-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一回我们说到了react需要的准备，现在我们说说如何使用React吧。 react的前置概念 React有一个核心思想—组件化 有两个带头大哥—react和react-dom 一个基本运作方式—数据驱动视图 一个神秘卧底—jsx语法 三个主要帮手—state（状态）、props（属性）、refs（实例） 打杂小弟—声明周期 react的使用react的两个带头大哥和神秘卧底jsx这么说完是不是什么都看不明白，好，我们具体举例子，在gitbash中输入 $ create-react-app &lt;file&gt;创建好文件夹后，在文件夹内运行npm start，默认打开localhost：3000端口可以打开默认react页面。在创建的文件夹内的public内，用编译器打开index.html，我们发现这个html内，除了一个id=root的空div之外，剩下没什么有用的内容了，但是是什么驱动了react默认页面的呢？ 我们把src内除了logo.svg与index.js之外的其他文件都删除掉，并且把index.js内容都删除掉。现在再加载npm start是不是页面上就应该什么都没有了，然后我们要自己在index.js文件里写些语句来实现数据驱动视图 12345678910//首先引入两个重要的模块import React from 'react'import ReactDOM from 'react-dom'//react-dom 负责页面内容的控制ReactDOM.render( &lt;h1&gt;我是react生成的内容&lt;/h1&gt;, document.getElementById('root')) 再在bash命令行里输入”npm start”，就可以在localhost：3000端口表现页面了 react-dom这样页面就可以显示出“我是react生成的内容”，其中react-dom有两个参数： 渲染的内容； 渲染进页面的位置。jsx渲染进页面的内容的h1标签是怎么被实现出来的呢？这里我请出了神秘卧底 jsx，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。我们不需要一定使用jsx，但它有以下优点： JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化； 它是类型安全的，在编译过程中就能发现错误； 使用 JSX 编写模板更加简单快速。react刚刚使用react-dom了，但是为什么要先引入react这个模块呢？因为我使用了 jsx，如果不引入react模块，则无法读取jsx语句 react的组件我们引入新的概念：react中的组件现在刚刚输入的index.js中继续输入，当输入以下内容时：12345ReactDOM.render( &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt;, document.getElementById('root')) 页面是会报错，不会显示任何内容，主要原因是，react-dom的第一个参数：渲染的内容，必须是由一个闭合标签引入。以上的内容可以通过以下解决报错问题：1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt; &lt;/div&gt;, document.getElementById('root')) 这样就可以了，第一个参数必须是闭合的标签，且里面的内容也应该是闭合的标签。然后我们说react中的组件,先举个例子12345678910111213141516171819//自定义一个Ul组件class Ul extends React.Component&#123; render()&#123; return( &lt;ul&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;li&gt;Text&lt;/li&gt; &lt;/ul&gt; )&#125; &#125;ReactDOM.render( &lt;div&gt; &lt;h1&gt;我是react生成的内容&lt;/h1&gt; &lt;Ul /&gt; &lt;/div&gt;, document.getElementById('root')) 如果引用react中的组件，必须先自定义个组件。具体操作为：class “Name” extends React.Component{render(){return(闭合的要渲染进去的内容)}} 在index.js中可以引入渲染中需要的css的。现在index.js先引入css文件：1import "./index.css" 渲染的时候就可以添加样式了。 插值可以是简单的表达式 123456789101112131415161718192021class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125; 渲染到html上就是：12342假的hello world下午8:00:51 但显示的时间仅是现在的时间，不能及时修改时间，我们暂且用这种想法试试呢？123456789101112131415161718192021222324class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; setInterval(()=&gt;&#123; this.state.time=(new Date()).toLocaleTimeString() &#125;,1000) &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125; 这样的写法也不会及时更改时间，永远不要直接修改state，如果要出现页面view的变化，要通过setState方法123setInterval(()=&gt;&#123; this.setState(&#123;time:(new Date()).toLocaleTimeString()&#125;) &#125;,1000) 这样显示的就是即时时间但都写在一个文件里，不太好，能不能通过引用组件呢？我们在index.js里写：1import Ul from './Ul.js' 在同级创建个Ul.js文件可以把有关Ul组件的东西考到Ul.js里，一定要在Ul.js里引用react，并在最后抛出Ul组件则在Ul.js里写：12345678910111213141516171819202122232425262728import React from "react"class Ul extends React.Component&#123; constructor()&#123; super(); this.state = &#123; time:(new Date()).toLocaleTimeString() &#125; setInterval(()=&gt;&#123; this.setState(&#123;time:(new Date()).toLocaleTimeString()&#125;) &#125;,1000) &#125; say()&#123; return("hello world") &#125; render()&#123; return( &lt;ul&gt; &lt;li&gt;&#123; 1+1 &#125;&lt;/li&gt; &lt;li&gt;&#123; 3&gt;4 ? '真的':'假的' &#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125;export default Ul jsx并不是真正的HTML标签，而是虚拟的DOM Tree我们会发现，刚刚实现的网页，在浏览器上，对象里，有个div，既不在head标签内，也不再body标签内，而是单独的一个div，点开会发现，里面有个#shadow-root,这个东西就是个 虚拟的 DOM Tree ，他是DOM结构的一个映射，一个影子。即在react一般不会在真实的DOM Tree里操作，一般是在虚拟的DOM Tree中实现，再投射在真实的DOM Tree。这里再说一下react厉害之处，它可以识别到真实的DOM Tree和虚拟的DOM Tree。比如刚刚的时间，原来使用的是把整个页面都重新刷新一遍，现在，只需要刷新时间这部分的内容就可以了。jsx中的{}插值的位置都很随意。]]></content>
      <tags>
        <tag>React,React基础,react,react-dom,数据驱动视图,jsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 初识（一）]]></title>
    <url>%2F2017%2F04%2F18%2FReact-%E5%88%9D%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[React是什么？ React.js（React）github上的原文解释是 A declarative, efficient, and flexible JavaScript library for building user interfaces.我个人翻译过来，一个 声明的，高效的，灵活的JavaScript库来构建用户界面。 React的起源React起源于Facebook的内部项目，因为该公司对市场上所有的JavaScript MVC框架，都不满意，于是他们就自己写了一套，当初是用来架设Instagram网站。做出来后，发现东西很好用，于是就开源了。 使用React需要什么准备？1. ES6 ES6的起源 1996年JavaScript提交给国际标准化组织ECMA，所以官方称呼这门语言为ECMAScript。 ECMAScript也需要不断的升级完善，2011年ECMAScript5.1版发布。 版本5的ECMAScript功能稳定，但基于nodejs的出现，ECMAScript觉得自己也得进步，于是在2015年发布了ECMAScript6，因为名字太长不好念，于是简写为ES6。 ES6的具体介绍详见 阮一峰大神的ES6入门 2. BABEL 当不使用BABEL，会有如下问题 各大浏览器老而弥坚。 浏览器更新速度快。 使用BABEL会解决这些问题 会使老浏览器焕发青春。 利用各种手段将ES6代码编译为ES5代码。 BABEL的问题：如何使BABEL自身自觉工作呢？ 3. webpack 使BABEL神不知鬼不觉进行工作的黑科技。 4. 然而以上三个不怎么重要，下面介绍一个create-react-app 具有： 来自Facebook的黑科技 自动安装webpack 自动安装babel 直接开始用ES6编译开发 安装create-react-app：先全局安装create-react-app - npm install -g create-react-app 创建create-react-app文件 - create-react-app &lt;file&gt; 下一章，将介绍如何使用react]]></content>
      <tags>
        <tag>React,React概念,ES6,Babel,Webpack,create-react-app</tag>
      </tags>
  </entry>
</search>